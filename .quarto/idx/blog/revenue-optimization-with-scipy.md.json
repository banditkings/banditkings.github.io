{"title":"Revenue Optimization with Price Elasticities and Scipy","markdown":{"yaml":{"title":"Revenue Optimization with Price Elasticities and Scipy","date":"2024-02-23","categories":["python","optimization","modeling"],"draft":false,"summary":"An introductory example of revenue optimization using the `minimize` function from `scipy.optimize`","images":["/static/images/scipy_optim/demand_curves.png","/static/images/scipy_optim/coef_dist.png","/static/images/scipy_optim/revenue_dist.png"],"layout":"PostLayout"},"headingText":"Price Elasticity of demand","containsRefs":false,"markdown":"\n\n- See also: [Scipy Optimization Manual](https://docs.scipy.org/doc/scipy/tutorial/optimize.html)\n\nFor many simple optimization problems, `scipy.optimize.minimize` ([docs](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html)) from `scipy` is all you need. In this example, we'll use product price elasticities to recommend prices that will optimize revenue when we have:\n\n1. A single product with known price elasticity\n2. Multiple products with known price elasticities\n3. Multiple products with uncertainty in price elasticities\n\n\nFirst - a refresher on price elasticity of demand. Let's say that we have a demand curve $Q = \\alpha P^{\\beta}$ which describes the demand $Q$ you would see for any given price $P$. $\\beta$ is our price elasticity coefficient, and $\\alpha$ represents the intercept (aka the amount of total demand for the product if the price was zero).\n\nBelow we'll create some simulated data with an elasticity coefficient $\\beta=-1.7$ and $\\alpha=2000$ and show both the demand and revenue curves:\n\n```python\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize\nfrom typing import List\n\n# price elasticity function\n\ndef demand(P, intercept, coef):\n    \"\"\"\n    Q = aP^{-B}\n    \"\"\"\n    return (intercept * P**(coef))\n\ndef revenue(P, intercept, coef):\n    \"\"\"\n    Set negative because we have a minimization problem,\n    so minimizing _negative_ revenue == maximizing revenue!\n    -P*Q = -P * aP^{-B}\n    \"\"\"\n    return -P*(intercept * P**(coef))\n```\n\nNext we'll simulate data and display the plots:\n\n```python\n# We can plot this relationship as follows with some simulated data\nx = np.linspace(10., 60., 50)\nalpha = 2000\nbeta = -1.7\ny = demand(x, alpha, beta)\ny2 = revenue(x, alpha, beta) * -1 # -1 for plotting\nf, ax = plt.subplots(1,2, figsize=(12,4))\n\nax[0].plot(x,y)\nax[0].set_xlabel(\"Price\")\nax[0].set_ylabel(\"Demand\")\nax[0].set_title(\"Demand Curve\")\nax[1].plot(x,y2)\nax[1].set_xlabel(\"Price\")\nax[1].set_ylabel(\"Revenue\")\nax[1].set_title(\"Revenue Curve\")\nf.suptitle(r\"Price Elasticity of Demand with $\\beta=-1.7, \\alpha=2000$\");\n```\n\n![img](/static/images/scipy_optim/demand_curves.png)\n\nNote the negative sign at the end of the `revenue` function. Since our goal is to _maximize_ revenue but we're using the `scipy.optimize.minimize` function, know that minimizing negative revenue is the same as maximizing positive revenue.\n\n## Aside: How to interpret a Log-Log Regression Coefficient\n\nRecall that we can decompose the price elasticity of demand function $Q = \\alpha P^{\\beta}$ into the sum of log terms and solve for the coefficient $\\beta$ in a log-log regression:\n\n$$\n\\begin{aligned}\nQ &= \\alpha P^{\\beta} \\\\\n\\rightarrow \\quad \\log(Q) &= \\beta \\log(P) + \\log(\\alpha)\n\\end{aligned}\n$$\n\nA common interpretation of $\\beta$ regression coefficient in a log-log model is that a $1\\%$ change in your predictor is associated with a $\\beta \\%$ change in your outcome variable. So in this example, with $\\beta=-1.7$, we would say that a $1\\%$ change in price would lead to a $-1.7\\%$ change in demand. It's important to note here that this is only an approximation, and moreover this only holds true for an exactly $1\\%$ increase in price. So it would not be accurate to say that a $10\\%$ increase in price would lead to a $-17\\%$ change in demand, nor would it be true that lowering the price $-1\\%$ would lead to a $1.7\\%$ _increase_ in demand!\n\n### Calculating impact\n\nThe formula for a percentage change associated with a $d$% change in price (holding everything else constant) is given by the following formula:\n\n$$\n\\begin{aligned}\n\\text{pct change in outcome} = e^{\\beta \\log(1 + d)} - 1\n\\end{aligned}\n$$\n\nwhere $d$ is the % change in price.\n\nFor example, if we wanted to estimate the percent change in demand $Q$ from a $-10\\%$ decrease (aka $d=-0.1$) in price for a product with $\\beta=-1.7$, this would be:\n\n$$\n\\begin{aligned}\ne^{-1.7 \\log(0.9)} - 1 \\approx 0.196\n\\end{aligned}\n$$\n\nwhich would correspond to a ~$19.6\\%$ increase in sales.\n\n**Notice that this isn't symmetric**, so a 10 percentage point price _increase_ for the same product would be associated with a 15% sales _decrease_:\n\n```python\ndef calc_change(coef:float, d:float)->float:\n    \"\"\"\n    Calculate the percentage change in demand given a\n    percent change `d` and elasticity coefficient `coef`\n    \"\"\"\n    return np.exp(coef * np.log(1+d)) - 1\n\ncalc_change(-1.7, 0.1)  # Returns -0.14958, a 15% sales decrease\n```\n\n## Optimization for a single product\n\nNext we'll take our baby steps into the `scipy.optimize.minimize` function where we try to find the price that maximizes revenue (minimizes negative revenue) for a _single_ product, using the same $\\beta=-1.7, \\alpha=2000$.\n\nThey key components for any optimization problem are:\n\n1. An objective function\n2. Constraints\n\nWe already specified our objective function `revenue` earlier in code, but now let's write it out explicitly. We're looking to maximize the revenue function $P \\times Q$:\n\n$$\n\\begin{aligned}\n\\argmax_P P Q &= \\argmin_P -P Q\\\\\n\\text{where} \\quad Q &=\\alpha P ^{\\beta}\n\\end{aligned}\n$$\n\nWhich is just our `revenue` function in math terms. Next, we'll specify our constraints for this problem.\n\n### Adding Inequality Constraints\n\nWhile `scipy` has stuff like `LinearConstraint`, I'm going to use a bunch of _inequality constraints_ that must be either a dictionary or list of dictionaries.\n\nAn inequality constraint should be a function of the form $C_j(x) \\ge 0$. So if we want to say that $x \\ge 10$, then subtract from both sides to get $x - 10 \\ge 0$.\n\nThen, we'll need to create a python function that returns $x-10$, and feed that in to our constraint dictionary, i.e:\n\n```python\ndef f(x):\n    return x - 10\n\n# scipy.optimize.minimize expects constraints as dicts\n# with a 'type' ('ineq' or 'eq') and 'fun' function\nconstraint = {'type':'ineq', 'fun':f}\n\n# Which is equivalent to:\nconstraint = {'type':'ineq', 'fun':lambda x: x-10}\n```\n\nAnd for multiple constraints, we simply put them together as a `list`:\n\n```python\n# For multiple constraints, we make a List[dict]\nconstraints = [{'type':'ineq', 'fun':lambda x: x - 10},\n               {'type':'ineq', 'fun':lambda x: 60 - x}]\n\n```\n\n_Note that from here out I'm going to be using `lambda` functions for brevity._\n\n### Minimize!\n\nWe're now ready to optimize our revenue function. Because we're using `minimize`, we had set our objective function `revenue` earlier to return a negative number, which turns this minimization function into a maximization problem. We'll pass in our initial guess `x0=10` and specify the `slope` and `intercept` arguments for the `revenue` function by adding the parameter `args=(alpha, beta)`.\n\nThis will return a optimization result object where we can display and extract useful information:\n\n```python\n# minimize revenue with initial guess of 10, args as a tuple,\n# and our list of constraints\nres = minimize(revenue, x0=10, args=(alpha, beta), constraints=constraints)\n# Display result:\nres\n```\n\n```\n     fun: -399.052462993776\n     jac: array([27.93367386])\n message: 'Optimization terminated successfully'\n    nfev: 2\n     nit: 1\n    njev: 1\n  status: 0\n success: True\n       x: array([10.])\n```\n\nIn the above result, we can see `res.x` is the optimal price that maximized revenue, and the 'best' revenue it found ended up being around \\$399. So for this highly elastic product, the best option is to reduce price as low as possible.\n\nNow, you might be wondering, what was the point of that? If we inspect the earlier revenue chart, we notice that this product is highly elastic and decreasing the price down to \\$10 would give us the highest revenue (around \\$400). We could have simply looked at the chart and gotten our answer that way, or used a simple `min.()` to find it. The upside of having `scipy.optimize` in your toolkit is that you can solve more complicated problems and save you the trouble at eyeballing charts!\n\n## Optimization with Multiple Products\n\nNow, we'll start adding some more complexity and go to optimizing revenue for 3 products instead of just one. Imagine we're a simple beverage stand and sell 3 products:\n\n- an entry-level 'Potion'\n- a mid-range 'Hi-Potion'\n- a high-end 'Max-Potion' for our wealthiest customers\n\nLet's say that we already have point estimates for the price elasticity coefficients, and our data is summarized as:\n\n```python\n# Imagine we have 3 products with 3 different elasticities:\ncoefs = [-2.5, -1.6, -0.7]\nprices = [10., 20., 30.]\nintercepts = [2000, 2000, 2000]\nproducts = {'product': ['Potion', 'Hi-Potion', 'Mega-Potion'],\n            'price': prices,\n            'elasticity': coefs,\n            'intercept': intercepts}\ndf = pd.DataFrame(products)\ndf\n```\n\n|     | product     | price | elasticity | intercept |\n| --- | ----------- | ----- | ---------- | --------- |\n| 0   | Potion      | 10.0  | -2.5       | 2000      |\n| 1   | Hi-Potion   | 20.0  | -1.6       | 2000      |\n| 2   | Mega-Potion | 30.0  | -0.7       | 2000      |\n\nWe'll update our objective function to now calculate _total_ sales for our products and call it `multiple_product_revenue`:\n\n```python\ndef multiple_product_revenue(P:List[float], intercepts:List[float], coefs:List[float]):\n    \"\"\"\n    Calculate total revenue from multiple products, given prices,\n    elasticity coefficients, and intercepts\n    \"\"\"\n    return -np.sum([p * intercepts[i] * (p**coefs[i]) for i,p in enumerate(P)])\n\nmultiple_product_revenue(prices, intercepts, coefs) # -5943.07\n```\n\nWhich is the same as:\n\n$$\n\\begin{aligned}\n\\argmin_P \\sum_{i=0}^{2} -P_iQ_i\n\\end{aligned}\n$$\n\n### Adding Constraints\n\nIn this case, we want to specify that the prices should follow some tiering logic, where each subsequent product should be priced higher than the previous one. For example, a 'Hi-potion' should be priced at least \\$5 higher than the 'Potion', and the 'Mega Potion' should be priced at least \\$5 higher than 'Hi-Potion'.\n\nFollowing the inequality constraints, this would like:\n\n$$\n\\begin{aligned}\nx_2 \\ge x_1 + 10 \\rightarrow \\quad x_2 - x_1 - 10 &\\ge 0\\\\\nx_1 \\ge x_0 + 10 \\rightarrow \\quad x_1 - x_0 - 10 &\\ge 0\n\\end{aligned}\n$$\n\nWe also need to specify some upper and lower bounds on this too, otherwise for highly elastic products the optimum will be too low, and conversely for highly inelastic products we want an upper bound or the optimizer will recommend an infinite price.\n\n$$\n\\begin{aligned}\nx_0 \\ge 10 \\rightarrow \\quad x_0 - 10 &\\ge 0\\\\\nx_2 \\le 60 \\rightarrow \\quad 60 - x_2 &\\ge 0\\\\\n\\end{aligned}\n$$\n\nWe'll add the rest of the constraints as `lambda` functions and then add all of the constraints as a list of dictionaries:\n\n```python\n# Multiple Constraints should be a list of dictionaries and we can use lambda functions instead\n\ncons = [{'type':'ineq', 'fun':lambda x: x[2] - x[1] - 10},\n        {'type':'ineq', 'fun':lambda x: x[1] - x[0] - 10},\n        {'type':'ineq', 'fun':lambda x: x[0] - 10},\n        {'type':'ineq', 'fun':lambda x: 60 - x[2]}] # Upper bound\n```\n\nThen we'll run our `minimize` call with this new function:\n\n```python\n# minimize\nmultiple_res = minimize(multiple_product_revenue, x0=prices,\n                        args=(intercepts, coefs), constraints=cons)\nmultiple_res\n```\n\n```\n     fun: -7225.550739696924\n     jac: array([  9.48681641,   9.94335938, -34.15441895])\n message: 'Optimization terminated successfully'\n    nfev: 8\n     nit: 2\n    njev: 2\n  status: 0\n success: True\n       x: array([10., 20., 60.])\n```\n\nWe see that it recommended prices of 10, 20, and 60 for our products for an optimal revenue of 7226. Much better than our baseline of 5943!\n\nRecall that the first two products were highly price elastic so it recommended a lower price, while the product with low price elasticity gets a higher recommended price. And of course, this doesn't take into account cross-price elasticities, other features that could drive sales, and other real-world concerns, but this should be sufficient.\n\n## Optimize Multiple Products with Uncertainty in our Elasiticity Coefficients\n\nWhat if there was uncertainty in our elasticity coefficient estimates (i.e. epistemic uncertainty)?\n\nWe could simply take the average coefficient estimate and use that as a point estimate, but in our pricing decision we may instead want to choose a different strategy, like minimax or maximin, etc.\n\nFor this example we'll maximize _expected_ revenue given a range of various coefficients that are normally distributed:\n\n```python\nnp.random.seed(42)\n\ndef simulate_coefficients(coefs:List[float], num_samples=1000)->np.ndarray:\n    # Simulate random draws of a number of coefficients\n    coef_samples = np.zeros((num_samples, len(coefs))) # (n,k)\n    std_dev = 0.15\n    for i,c in enumerate(coefs):\n        coef_samples[:, i] = np.random.normal(c, std_dev, num_samples)\n    return coef_samples\n\n# Get a 2D array of shape (1000, 3) of coefficient samples\ncoef_samples = simulate_coefficients(coefs, 1000)\nf, ax = plt.subplots(1,3, figsize=(12,4))\nfor i in range(3):\n    ax[i].axvline(coefs[i], c='black', linestyle='--')\n    ax[i].hist(coef_samples[:, i])\n    ax[i].set_title(rf\"$\\beta_{i}$\")\nf.suptitle(\"Elasticity Coefficient Distributions\");\n```\n\n![img](/static/images/scipy_optim/coef_dist.png)\n\nNext we'll need to restate our objective function because instead of having a list of 3 coefficients, now we have 1000 samples from each of the coefficient distributions in a $(1000, 3)$ array, where each row represents a sample of each of the coefficients and each column is a different coefficient/product.\n\nSince each row is a distinct combination of samples from these three distributions, we can calculate sales for each of the 1000 combinations of coefficients and get the average for a given product price scenario.\n\n```python\ndef uncertain_revenues(prices:List[float],\n                       coef_samples:np.ndarray,\n                       intercepts:List[float],\n                       agg_func=np.mean):\n    \"\"\"\n    Calculate Total Sales for each of the independent samples\n    \"\"\"\n    demand_array = np.zeros(coef_samples.shape)\n    revenue_array = np.zeros(coef_samples.shape)\n\n    # Iterate for each product to calucate product sales for each\n    # sample of its elasticity coefficient\n    for i,p in enumerate(prices):\n        # Calculate Demand and Revenue for a single product\n        _demands = intercepts[i] * p**(coef_samples[:, i])\n        demand_array[:,i] = _demands\n        revenue_array[:, i] = p * _demands\n\n    # To get total revenue, we sum the individual product revenues\n    # by summing each row in our (n, P) revenue matrix\n    total_revenues = np.sum(revenue_array, axis=1) # (n,) revenues\n    if agg_func=='None':\n        return -total_revenues\n    else:\n        return -agg_func(total_revenues)\n```\n\nBefore we run this optimization problem, we can look at the distribution of total sales with our new coefficient samples and baseline prices ($P=[10,20,30]$)\n\n```python\ntotal_revenues = uncertain_revenues(prices, coef_samples, intercepts, agg_func='None')\n\n# Plot\nplt.hist(total_revenues * -1)\nmean_revenue = np.mean(total_revenues * -1)\nplt.axvline(mean_revenue, c='black', linestyle='--',\n            label=f\"Mean: {np.round(mean_revenue,2)}\")\nplt.legend()\nplt.title(\"Distribution of Total Revenues for P=[10,20,30] with Coefficient Uncertainty\");\n```\n\n![img](/static/images/scipy_optim/revenue_dist.png)\n\nNote that the average sales is quite a bit higher than if we had just used the point estimates for the $\\beta$ price elasticity coefficients at the same prices.\n\nFinally, we take our new total revenue function `uncertain_revenues` and plug it in to the `scipy.optimize.minimize` function with the same constraints as before:\n\n```python\nuncertain_res = minimize(uncertain_revenues, x0=prices,\n                         args=(coef_samples, intercepts, np.mean),\n                         constraints=cons)\nuncertain_res\n```\n\n```\n     fun: -8700.021202981006\n     jac: array([  9.75854492,   9.88623047, -54.04797363])\n message: 'Optimization terminated successfully'\n    nfev: 8\n     nit: 2\n    njev: 2\n  status: 0\n success: True\n       x: array([10., 20., 60.])\n```\n\nAnd interestingly enough, we arrive at the same recommendation, but now we have a higher optimal value thanks to the variation in our coefficient estimates.\n\n### Trying alternate strategies: Maximax\n\nRecall that the `uncertain_revenues` function we made earlier had an argument called `agg_func` to specify the aggregation methodology. When we maximized expected revenue, we took the mean of the revenues but we can go a little further and modify our objective function to provide the prices that maximize the _maximum_ revenue instead of the expected/mean revenue. This is the \"maximax\" strategy, where we wish to find the prices that maximize the \"best case\" revenue:\n\n```python\nminimize(uncertain_revenues, x0=prices,\n         args=(coef_samples, intercepts, np.max),\n         constraints=cons)\n```\n\n```\n     fun: -76513.68494954193\n     jac: array([   11.09960938,     9.19921875, -1128.265625  ])\n message: 'Optimization terminated successfully'\n    nfev: 9\n     nit: 2\n    njev: 2\n  status: 0\n success: True\n       x: array([10.        , 20.        , 59.99999999])\n```\n\n### Trying alternate strategies: Maximin\n\nOr conversely there's the 'maximin' strategy in which we want to find the prices that give us the best of the worst case scenarios:\n\n```python\nminimize(uncertain_revenues, x0=prices,\n         args=(coef_samples, intercepts, np.min),\n         constraints=cons)\n```\n\n```\n     fun: -1583.1352057625413\n     jac: array([7.98712158, 9.88525391, 5.97763062])\n message: 'Optimization terminated successfully'\n    nfev: 4\n     nit: 1\n    njev: 1\n  status: 0\n success: True\n       x: array([10., 20., 30.])\n```\n\n## Summary\n\nThe `scipy.optimize.minimize` function is a powerful tool in your optimization toolkit that can help solve both linear and nonlinear optimization problems with a very simple interface. It takes in an arbitrary function (which in this case was quadratric) and a list of constraints and then it does all the magic behind the scenes. For simple business problems like this product pricing example, I found `minimize` to be an ideal mix between performance and ease of use. The easy stuff is easy - but as things get more complicated, (i.e. mixed integer problems, network optimization, etc) you'll need to reach out to more advanced libraries like Google's `or-tools` ([link](https://developers.google.com/optimization)).\n","srcMarkdownNoYaml":"\n\n- See also: [Scipy Optimization Manual](https://docs.scipy.org/doc/scipy/tutorial/optimize.html)\n\nFor many simple optimization problems, `scipy.optimize.minimize` ([docs](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html)) from `scipy` is all you need. In this example, we'll use product price elasticities to recommend prices that will optimize revenue when we have:\n\n1. A single product with known price elasticity\n2. Multiple products with known price elasticities\n3. Multiple products with uncertainty in price elasticities\n\n## Price Elasticity of demand\n\nFirst - a refresher on price elasticity of demand. Let's say that we have a demand curve $Q = \\alpha P^{\\beta}$ which describes the demand $Q$ you would see for any given price $P$. $\\beta$ is our price elasticity coefficient, and $\\alpha$ represents the intercept (aka the amount of total demand for the product if the price was zero).\n\nBelow we'll create some simulated data with an elasticity coefficient $\\beta=-1.7$ and $\\alpha=2000$ and show both the demand and revenue curves:\n\n```python\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize\nfrom typing import List\n\n# price elasticity function\n\ndef demand(P, intercept, coef):\n    \"\"\"\n    Q = aP^{-B}\n    \"\"\"\n    return (intercept * P**(coef))\n\ndef revenue(P, intercept, coef):\n    \"\"\"\n    Set negative because we have a minimization problem,\n    so minimizing _negative_ revenue == maximizing revenue!\n    -P*Q = -P * aP^{-B}\n    \"\"\"\n    return -P*(intercept * P**(coef))\n```\n\nNext we'll simulate data and display the plots:\n\n```python\n# We can plot this relationship as follows with some simulated data\nx = np.linspace(10., 60., 50)\nalpha = 2000\nbeta = -1.7\ny = demand(x, alpha, beta)\ny2 = revenue(x, alpha, beta) * -1 # -1 for plotting\nf, ax = plt.subplots(1,2, figsize=(12,4))\n\nax[0].plot(x,y)\nax[0].set_xlabel(\"Price\")\nax[0].set_ylabel(\"Demand\")\nax[0].set_title(\"Demand Curve\")\nax[1].plot(x,y2)\nax[1].set_xlabel(\"Price\")\nax[1].set_ylabel(\"Revenue\")\nax[1].set_title(\"Revenue Curve\")\nf.suptitle(r\"Price Elasticity of Demand with $\\beta=-1.7, \\alpha=2000$\");\n```\n\n![img](/static/images/scipy_optim/demand_curves.png)\n\nNote the negative sign at the end of the `revenue` function. Since our goal is to _maximize_ revenue but we're using the `scipy.optimize.minimize` function, know that minimizing negative revenue is the same as maximizing positive revenue.\n\n## Aside: How to interpret a Log-Log Regression Coefficient\n\nRecall that we can decompose the price elasticity of demand function $Q = \\alpha P^{\\beta}$ into the sum of log terms and solve for the coefficient $\\beta$ in a log-log regression:\n\n$$\n\\begin{aligned}\nQ &= \\alpha P^{\\beta} \\\\\n\\rightarrow \\quad \\log(Q) &= \\beta \\log(P) + \\log(\\alpha)\n\\end{aligned}\n$$\n\nA common interpretation of $\\beta$ regression coefficient in a log-log model is that a $1\\%$ change in your predictor is associated with a $\\beta \\%$ change in your outcome variable. So in this example, with $\\beta=-1.7$, we would say that a $1\\%$ change in price would lead to a $-1.7\\%$ change in demand. It's important to note here that this is only an approximation, and moreover this only holds true for an exactly $1\\%$ increase in price. So it would not be accurate to say that a $10\\%$ increase in price would lead to a $-17\\%$ change in demand, nor would it be true that lowering the price $-1\\%$ would lead to a $1.7\\%$ _increase_ in demand!\n\n### Calculating impact\n\nThe formula for a percentage change associated with a $d$% change in price (holding everything else constant) is given by the following formula:\n\n$$\n\\begin{aligned}\n\\text{pct change in outcome} = e^{\\beta \\log(1 + d)} - 1\n\\end{aligned}\n$$\n\nwhere $d$ is the % change in price.\n\nFor example, if we wanted to estimate the percent change in demand $Q$ from a $-10\\%$ decrease (aka $d=-0.1$) in price for a product with $\\beta=-1.7$, this would be:\n\n$$\n\\begin{aligned}\ne^{-1.7 \\log(0.9)} - 1 \\approx 0.196\n\\end{aligned}\n$$\n\nwhich would correspond to a ~$19.6\\%$ increase in sales.\n\n**Notice that this isn't symmetric**, so a 10 percentage point price _increase_ for the same product would be associated with a 15% sales _decrease_:\n\n```python\ndef calc_change(coef:float, d:float)->float:\n    \"\"\"\n    Calculate the percentage change in demand given a\n    percent change `d` and elasticity coefficient `coef`\n    \"\"\"\n    return np.exp(coef * np.log(1+d)) - 1\n\ncalc_change(-1.7, 0.1)  # Returns -0.14958, a 15% sales decrease\n```\n\n## Optimization for a single product\n\nNext we'll take our baby steps into the `scipy.optimize.minimize` function where we try to find the price that maximizes revenue (minimizes negative revenue) for a _single_ product, using the same $\\beta=-1.7, \\alpha=2000$.\n\nThey key components for any optimization problem are:\n\n1. An objective function\n2. Constraints\n\nWe already specified our objective function `revenue` earlier in code, but now let's write it out explicitly. We're looking to maximize the revenue function $P \\times Q$:\n\n$$\n\\begin{aligned}\n\\argmax_P P Q &= \\argmin_P -P Q\\\\\n\\text{where} \\quad Q &=\\alpha P ^{\\beta}\n\\end{aligned}\n$$\n\nWhich is just our `revenue` function in math terms. Next, we'll specify our constraints for this problem.\n\n### Adding Inequality Constraints\n\nWhile `scipy` has stuff like `LinearConstraint`, I'm going to use a bunch of _inequality constraints_ that must be either a dictionary or list of dictionaries.\n\nAn inequality constraint should be a function of the form $C_j(x) \\ge 0$. So if we want to say that $x \\ge 10$, then subtract from both sides to get $x - 10 \\ge 0$.\n\nThen, we'll need to create a python function that returns $x-10$, and feed that in to our constraint dictionary, i.e:\n\n```python\ndef f(x):\n    return x - 10\n\n# scipy.optimize.minimize expects constraints as dicts\n# with a 'type' ('ineq' or 'eq') and 'fun' function\nconstraint = {'type':'ineq', 'fun':f}\n\n# Which is equivalent to:\nconstraint = {'type':'ineq', 'fun':lambda x: x-10}\n```\n\nAnd for multiple constraints, we simply put them together as a `list`:\n\n```python\n# For multiple constraints, we make a List[dict]\nconstraints = [{'type':'ineq', 'fun':lambda x: x - 10},\n               {'type':'ineq', 'fun':lambda x: 60 - x}]\n\n```\n\n_Note that from here out I'm going to be using `lambda` functions for brevity._\n\n### Minimize!\n\nWe're now ready to optimize our revenue function. Because we're using `minimize`, we had set our objective function `revenue` earlier to return a negative number, which turns this minimization function into a maximization problem. We'll pass in our initial guess `x0=10` and specify the `slope` and `intercept` arguments for the `revenue` function by adding the parameter `args=(alpha, beta)`.\n\nThis will return a optimization result object where we can display and extract useful information:\n\n```python\n# minimize revenue with initial guess of 10, args as a tuple,\n# and our list of constraints\nres = minimize(revenue, x0=10, args=(alpha, beta), constraints=constraints)\n# Display result:\nres\n```\n\n```\n     fun: -399.052462993776\n     jac: array([27.93367386])\n message: 'Optimization terminated successfully'\n    nfev: 2\n     nit: 1\n    njev: 1\n  status: 0\n success: True\n       x: array([10.])\n```\n\nIn the above result, we can see `res.x` is the optimal price that maximized revenue, and the 'best' revenue it found ended up being around \\$399. So for this highly elastic product, the best option is to reduce price as low as possible.\n\nNow, you might be wondering, what was the point of that? If we inspect the earlier revenue chart, we notice that this product is highly elastic and decreasing the price down to \\$10 would give us the highest revenue (around \\$400). We could have simply looked at the chart and gotten our answer that way, or used a simple `min.()` to find it. The upside of having `scipy.optimize` in your toolkit is that you can solve more complicated problems and save you the trouble at eyeballing charts!\n\n## Optimization with Multiple Products\n\nNow, we'll start adding some more complexity and go to optimizing revenue for 3 products instead of just one. Imagine we're a simple beverage stand and sell 3 products:\n\n- an entry-level 'Potion'\n- a mid-range 'Hi-Potion'\n- a high-end 'Max-Potion' for our wealthiest customers\n\nLet's say that we already have point estimates for the price elasticity coefficients, and our data is summarized as:\n\n```python\n# Imagine we have 3 products with 3 different elasticities:\ncoefs = [-2.5, -1.6, -0.7]\nprices = [10., 20., 30.]\nintercepts = [2000, 2000, 2000]\nproducts = {'product': ['Potion', 'Hi-Potion', 'Mega-Potion'],\n            'price': prices,\n            'elasticity': coefs,\n            'intercept': intercepts}\ndf = pd.DataFrame(products)\ndf\n```\n\n|     | product     | price | elasticity | intercept |\n| --- | ----------- | ----- | ---------- | --------- |\n| 0   | Potion      | 10.0  | -2.5       | 2000      |\n| 1   | Hi-Potion   | 20.0  | -1.6       | 2000      |\n| 2   | Mega-Potion | 30.0  | -0.7       | 2000      |\n\nWe'll update our objective function to now calculate _total_ sales for our products and call it `multiple_product_revenue`:\n\n```python\ndef multiple_product_revenue(P:List[float], intercepts:List[float], coefs:List[float]):\n    \"\"\"\n    Calculate total revenue from multiple products, given prices,\n    elasticity coefficients, and intercepts\n    \"\"\"\n    return -np.sum([p * intercepts[i] * (p**coefs[i]) for i,p in enumerate(P)])\n\nmultiple_product_revenue(prices, intercepts, coefs) # -5943.07\n```\n\nWhich is the same as:\n\n$$\n\\begin{aligned}\n\\argmin_P \\sum_{i=0}^{2} -P_iQ_i\n\\end{aligned}\n$$\n\n### Adding Constraints\n\nIn this case, we want to specify that the prices should follow some tiering logic, where each subsequent product should be priced higher than the previous one. For example, a 'Hi-potion' should be priced at least \\$5 higher than the 'Potion', and the 'Mega Potion' should be priced at least \\$5 higher than 'Hi-Potion'.\n\nFollowing the inequality constraints, this would like:\n\n$$\n\\begin{aligned}\nx_2 \\ge x_1 + 10 \\rightarrow \\quad x_2 - x_1 - 10 &\\ge 0\\\\\nx_1 \\ge x_0 + 10 \\rightarrow \\quad x_1 - x_0 - 10 &\\ge 0\n\\end{aligned}\n$$\n\nWe also need to specify some upper and lower bounds on this too, otherwise for highly elastic products the optimum will be too low, and conversely for highly inelastic products we want an upper bound or the optimizer will recommend an infinite price.\n\n$$\n\\begin{aligned}\nx_0 \\ge 10 \\rightarrow \\quad x_0 - 10 &\\ge 0\\\\\nx_2 \\le 60 \\rightarrow \\quad 60 - x_2 &\\ge 0\\\\\n\\end{aligned}\n$$\n\nWe'll add the rest of the constraints as `lambda` functions and then add all of the constraints as a list of dictionaries:\n\n```python\n# Multiple Constraints should be a list of dictionaries and we can use lambda functions instead\n\ncons = [{'type':'ineq', 'fun':lambda x: x[2] - x[1] - 10},\n        {'type':'ineq', 'fun':lambda x: x[1] - x[0] - 10},\n        {'type':'ineq', 'fun':lambda x: x[0] - 10},\n        {'type':'ineq', 'fun':lambda x: 60 - x[2]}] # Upper bound\n```\n\nThen we'll run our `minimize` call with this new function:\n\n```python\n# minimize\nmultiple_res = minimize(multiple_product_revenue, x0=prices,\n                        args=(intercepts, coefs), constraints=cons)\nmultiple_res\n```\n\n```\n     fun: -7225.550739696924\n     jac: array([  9.48681641,   9.94335938, -34.15441895])\n message: 'Optimization terminated successfully'\n    nfev: 8\n     nit: 2\n    njev: 2\n  status: 0\n success: True\n       x: array([10., 20., 60.])\n```\n\nWe see that it recommended prices of 10, 20, and 60 for our products for an optimal revenue of 7226. Much better than our baseline of 5943!\n\nRecall that the first two products were highly price elastic so it recommended a lower price, while the product with low price elasticity gets a higher recommended price. And of course, this doesn't take into account cross-price elasticities, other features that could drive sales, and other real-world concerns, but this should be sufficient.\n\n## Optimize Multiple Products with Uncertainty in our Elasiticity Coefficients\n\nWhat if there was uncertainty in our elasticity coefficient estimates (i.e. epistemic uncertainty)?\n\nWe could simply take the average coefficient estimate and use that as a point estimate, but in our pricing decision we may instead want to choose a different strategy, like minimax or maximin, etc.\n\nFor this example we'll maximize _expected_ revenue given a range of various coefficients that are normally distributed:\n\n```python\nnp.random.seed(42)\n\ndef simulate_coefficients(coefs:List[float], num_samples=1000)->np.ndarray:\n    # Simulate random draws of a number of coefficients\n    coef_samples = np.zeros((num_samples, len(coefs))) # (n,k)\n    std_dev = 0.15\n    for i,c in enumerate(coefs):\n        coef_samples[:, i] = np.random.normal(c, std_dev, num_samples)\n    return coef_samples\n\n# Get a 2D array of shape (1000, 3) of coefficient samples\ncoef_samples = simulate_coefficients(coefs, 1000)\nf, ax = plt.subplots(1,3, figsize=(12,4))\nfor i in range(3):\n    ax[i].axvline(coefs[i], c='black', linestyle='--')\n    ax[i].hist(coef_samples[:, i])\n    ax[i].set_title(rf\"$\\beta_{i}$\")\nf.suptitle(\"Elasticity Coefficient Distributions\");\n```\n\n![img](/static/images/scipy_optim/coef_dist.png)\n\nNext we'll need to restate our objective function because instead of having a list of 3 coefficients, now we have 1000 samples from each of the coefficient distributions in a $(1000, 3)$ array, where each row represents a sample of each of the coefficients and each column is a different coefficient/product.\n\nSince each row is a distinct combination of samples from these three distributions, we can calculate sales for each of the 1000 combinations of coefficients and get the average for a given product price scenario.\n\n```python\ndef uncertain_revenues(prices:List[float],\n                       coef_samples:np.ndarray,\n                       intercepts:List[float],\n                       agg_func=np.mean):\n    \"\"\"\n    Calculate Total Sales for each of the independent samples\n    \"\"\"\n    demand_array = np.zeros(coef_samples.shape)\n    revenue_array = np.zeros(coef_samples.shape)\n\n    # Iterate for each product to calucate product sales for each\n    # sample of its elasticity coefficient\n    for i,p in enumerate(prices):\n        # Calculate Demand and Revenue for a single product\n        _demands = intercepts[i] * p**(coef_samples[:, i])\n        demand_array[:,i] = _demands\n        revenue_array[:, i] = p * _demands\n\n    # To get total revenue, we sum the individual product revenues\n    # by summing each row in our (n, P) revenue matrix\n    total_revenues = np.sum(revenue_array, axis=1) # (n,) revenues\n    if agg_func=='None':\n        return -total_revenues\n    else:\n        return -agg_func(total_revenues)\n```\n\nBefore we run this optimization problem, we can look at the distribution of total sales with our new coefficient samples and baseline prices ($P=[10,20,30]$)\n\n```python\ntotal_revenues = uncertain_revenues(prices, coef_samples, intercepts, agg_func='None')\n\n# Plot\nplt.hist(total_revenues * -1)\nmean_revenue = np.mean(total_revenues * -1)\nplt.axvline(mean_revenue, c='black', linestyle='--',\n            label=f\"Mean: {np.round(mean_revenue,2)}\")\nplt.legend()\nplt.title(\"Distribution of Total Revenues for P=[10,20,30] with Coefficient Uncertainty\");\n```\n\n![img](/static/images/scipy_optim/revenue_dist.png)\n\nNote that the average sales is quite a bit higher than if we had just used the point estimates for the $\\beta$ price elasticity coefficients at the same prices.\n\nFinally, we take our new total revenue function `uncertain_revenues` and plug it in to the `scipy.optimize.minimize` function with the same constraints as before:\n\n```python\nuncertain_res = minimize(uncertain_revenues, x0=prices,\n                         args=(coef_samples, intercepts, np.mean),\n                         constraints=cons)\nuncertain_res\n```\n\n```\n     fun: -8700.021202981006\n     jac: array([  9.75854492,   9.88623047, -54.04797363])\n message: 'Optimization terminated successfully'\n    nfev: 8\n     nit: 2\n    njev: 2\n  status: 0\n success: True\n       x: array([10., 20., 60.])\n```\n\nAnd interestingly enough, we arrive at the same recommendation, but now we have a higher optimal value thanks to the variation in our coefficient estimates.\n\n### Trying alternate strategies: Maximax\n\nRecall that the `uncertain_revenues` function we made earlier had an argument called `agg_func` to specify the aggregation methodology. When we maximized expected revenue, we took the mean of the revenues but we can go a little further and modify our objective function to provide the prices that maximize the _maximum_ revenue instead of the expected/mean revenue. This is the \"maximax\" strategy, where we wish to find the prices that maximize the \"best case\" revenue:\n\n```python\nminimize(uncertain_revenues, x0=prices,\n         args=(coef_samples, intercepts, np.max),\n         constraints=cons)\n```\n\n```\n     fun: -76513.68494954193\n     jac: array([   11.09960938,     9.19921875, -1128.265625  ])\n message: 'Optimization terminated successfully'\n    nfev: 9\n     nit: 2\n    njev: 2\n  status: 0\n success: True\n       x: array([10.        , 20.        , 59.99999999])\n```\n\n### Trying alternate strategies: Maximin\n\nOr conversely there's the 'maximin' strategy in which we want to find the prices that give us the best of the worst case scenarios:\n\n```python\nminimize(uncertain_revenues, x0=prices,\n         args=(coef_samples, intercepts, np.min),\n         constraints=cons)\n```\n\n```\n     fun: -1583.1352057625413\n     jac: array([7.98712158, 9.88525391, 5.97763062])\n message: 'Optimization terminated successfully'\n    nfev: 4\n     nit: 1\n    njev: 1\n  status: 0\n success: True\n       x: array([10., 20., 30.])\n```\n\n## Summary\n\nThe `scipy.optimize.minimize` function is a powerful tool in your optimization toolkit that can help solve both linear and nonlinear optimization problems with a very simple interface. It takes in an arbitrary function (which in this case was quadratric) and a list of constraints and then it does all the magic behind the scenes. For simple business problems like this product pricing example, I found `minimize` to be an ideal mix between performance and ease of use. The easy stuff is easy - but as things get more complicated, (i.e. mixed integer problems, network optimization, etc) you'll need to reach out to more advanced libraries like Google's `or-tools` ([link](https://developers.google.com/optimization)).\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"revenue-optimization-with-scipy.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.52","theme":{"light":"cosmo"},"title-block-banner":true,"title":"Revenue Optimization with Price Elasticities and Scipy","date":"2024-02-23","categories":["python","optimization","modeling"],"draft":false,"summary":"An introductory example of revenue optimization using the `minimize` function from `scipy.optimize`","images":["/static/images/scipy_optim/demand_curves.png","/static/images/scipy_optim/coef_dist.png","/static/images/scipy_optim/revenue_dist.png"],"layout":"PostLayout"},"extensions":{"book":{"multiFile":true}}}},"draft":false,"projectFormats":["html"]}