{"title":"Making Custom Fiscal 52/53 Workweek Calendars in Pandas","markdown":{"yaml":{"title":"Making Custom Fiscal 52/53 Workweek Calendars in Pandas","date":"2022-02-20","tags":["python"],"categories":["modeling"],"summary":"How to build custom financial calendars that have 52 or 53 workweeks in a fiscal year (aka the 4-4-5 calendar) using `pandas`","canonicalUrl":"https://www.nelsontang.com/blog/fiscal-5253-workweek-calendar-in-pandas"},"headingText":"TLDR","containsRefs":false,"markdown":"\n\n_Last run on pandas 1.1.3_\n\n\n- Here's the [gist](https://gist.github.com/banditkings/735fe1885a442b3457d208060ac4b970)\n- Notebook versions: [[ipynb]](https://github.com/banditkings/random-python-examples/blob/main/time-series-python/pandas-time-functions.ipynb)[[html]](https://github.com/banditkings/random-python-examples/blob/main/time-series-python/pandas-time-functions.ipynb)\n\n# Fiscal Calendars Should Be Easy, Right?\n\nUnless your company's fiscal calendar lines up exactly with the calendar year, you'll inevitably encounter issues with custom fiscal calendars. Analysts will usually have some lookup table either in a spreadsheet or a friendly database table that they're trained to query and pull in every time someone asks: _'how did we perform this quarter compared to last quarter?'_\n\nBut what about making a lookup table _programmatically_, or what if you don't have a tidy lookup table handed to you? For example, let's say you work in a paper supplier and you have a table of forecasted supply and you need to match that data to demand that each customer sent over in spreadsheets. Now imagine each customer sent you demand according to their fiscal calendar. Welcome to hell!\n\n# Building Standard Fiscal Calendars in `pandas`\n\nSo what can you do in basic `pandas`? Well, if your fiscal calendar is the same as the calendar year, you're in luck.\n\n`pandas` has a variety of functions that let you create and manipulate date ranges that conform to a fiscal calendar that begins on January 1st of every year and ends on Dec 31st of every year, and where every quarter is exactly 3 calendar months long.\n\nWe can see an example of this built-in functionality if we use `pandas` to give us an array of the _last_ day in each quarter in 2021 using the `freq='Q'` parameter:\n\n```python\nimport datetime\nimport numpy as np\nimport pandas as pd\n\nstart = datetime.datetime(2021, 1, 1)\nend = datetime.datetime(2022, 1, 1)\n# Create a DatetimeIndex with freq='Q'\n# the 'Q' indicates the last day of each quarter\nts = pd.date_range(start, end, freq='Q')\nts\n```\n\nWhich returns an iterable `DatetimeIndex` object with a few extra parameters:\n\n```\nDatetimeIndex(['2021-03-31', '2021-06-30', '2021-09-30', '2021-12-31'], dtype='datetime64[ns]', freq='Q-DEC')\n```\n\nWe can use this index to create a dataframe with columns with various attributes, by converting this stuff to a `period` object:\n\n```python\ntp = ts.to_period()\n\npd.DataFrame(index=ts,\n             data={'quarter':tp.quarter,\n                   'fiscal_year':tp.qyear})\n```\n\n|            | quarter | fiscal_year |\n| :--------- | ------: | ----------: |\n| 2021-03-31 |       1 |        2021 |\n| 2021-06-30 |       2 |        2021 |\n| 2021-09-30 |       3 |        2021 |\n| 2021-12-31 |       4 |        2021 |\n\nHowever, what if you wanted to use `pandas` to handle fiscal calendars that aren't set to this standard? For example, let's say we have a fiscal calendar that starts on June 1st (i.e. Nike).\n\nNotice that the previous creation of a `pd.date_range` with `freq='Q'` created a DatetimeIndex with a freq of `'Q-DEC'`. While there's a list of ['frequency or offset aliases'](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases) there isn't much mention of what `'Q-DEC'` is except mentioned briefly in the [Pandas user guide](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#frequency-conversion-and-resampling-with-periodindex):\n\n> Many organizations define quarters relative to the month in which their fiscal year starts and ends. Thus, first quarter of 2011 could start in 2010 or a few months into 2011. Via anchored frequencies, pandas works for all quarterly frequencies `Q-JAN` through `Q-DEC`.\n\nSo in other words, the default quarter system `Q-DEC` (and `A-DEC`) means that it ends in December. So if we wanted to have a fiscal calendar that ends in May and starts in June 1st, we'd use `Q-MAY`:\n\n```python\nts = pd.date_range(start, end, freq='Q-MAY')\ntp = ts.to_period()\n\npd.DataFrame(index=ts, data={'quarter':tp.quarter, 'fiscal_year':tp.qyear})\n```\n\n|            | quarter | fiscal_year |\n| :--------- | ------: | ----------: |\n| 2021-02-28 |       3 |        2021 |\n| 2021-05-31 |       4 |        2021 |\n| 2021-08-31 |       1 |        2022 |\n| 2021-11-30 |       2 |        2022 |\n\nSo that was easy! And instead of creating the date range with just the end quarters, we can create a daily date range and then use the `to_period()` call to do the fiscal year translation for us, to create a _daily_ calendar lookup table:\n\n```python\n# create a DatetimeIndex with all days between 2021 and 2022\nts = pd.date_range(start='2021', end='2022', freq='D')\n\n# Create a PeriodIndex from the daily range with our new freq\ntp = ts.to_period(freq='Q-MAY')\ndf = pd.DataFrame(index=ts,\n                  data={'quarter':tp.quarter,\n                        'fiscal_year':tp.qyear})\ndf.tail()\n```\n\n|            | quarter | fiscal_year |\n| :--------- | ------: | ----------: |\n| 2021-12-28 |       3 |        2022 |\n| 2021-12-29 |       3 |        2022 |\n| 2021-12-30 |       3 |        2022 |\n| 2021-12-31 |       3 |        2022 |\n| 2022-01-01 |       3 |        2022 |\n\nWe can see that the correct fiscal year and fiscal quarters are represented. Nice!\n\n# 52/53 Workweek Calendars\n\nWhat if your fiscal calendar follows a [52/53-workweek calendar using the 4-4-5 quarter system](https://en.wikipedia.org/wiki/4–4–5_calendar)? I want to be able to use `pandas` methods on those, too!\n\nAn exhaustive search in `pandas` docs comes up with a custom DateOffset class that has the barest minimum in terms of [documentation](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.FY5253.html): `pd.tseries.offsets.FY5253`.\n\nWe can use the `pd.tseries.offsets.FY5253` DateOffset type to find the dates of the beginning of each fiscal year:\n\n```python\nvariation = 'last'\n\n# create an offset for the Intel fiscal calendar, which ends on the last Saturday of December\nyoffset = pd.tseries.offsets.FY5253(n=1, weekday=5, startingMonth=12, variation=variation)\n\n# use the offset to create a date range with intervals at each fiscal year beginning\nyoffset_range = pd.date_range('2020', periods=3, freq=yoffset)\nyoffset_range\n```\n\n```\nDatetimeIndex(['2020-12-26', '2021-12-25', '2022-12-31'], dtype='datetime64[ns]', freq='RE-L-DEC-SAT')\n```\n\nLet's take a look at the above result - we've generated a `DatetimeIndex` with the _last_ day of each fiscal year. In this case, we are telling `pandas` to create an offset using a 52/53 workweek calendar where the last day of the fiscal calendar lands on **the last (`variation='last'`) Saturday (`weekday=5`) in December (`month=12`)**. See [documentation](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.FY5253.html) for an explainer on the other parameters, and the 'nearest' variation.\n\nNotice the new `freq` string. Creating the timeseries offset object generates a new `freq` string that you can use for the `pd.date_range` function. However, unlike the previous examples you can't convert these to `Period` objects to get the quarter, month, etc (you can try it - it'll return an error).\n\nSo how can we use this to create a lookup table? We can do it manually with a loop and `pd.date_range`:\n\n```python\n# Create a '1 day' offset:\nd1 = pd.tseries.offsets.DateOffset(n = 1)\n\n# Specify the starting fiscal year\nyr = (yoffset_range[0] - pd.tseries.offsets.DateOffset(n=8)).year +1\n\n# iterate over each item in the date range we created earlier:\nresult = pd.DataFrame()\nfor i in yoffset_range:\n    # recall each item is a Timestamp that represents the first day of the fiscal year,\n    # so create a date_range from beginning to end of the fiscal year\n    current_range = pd.date_range(i+d1, i+yoffset, freq='D')\n    interim_df = pd.DataFrame(index = current_range)\n    # day of year\n    interim_df['DOY'] = (current_range-current_range[0]).days +1\n    # fiscal year\n    interim_df['FY'] = yr\n    result = result.append(interim_df)\n    yr += 1\n\n# See what we get:\nresult.query('FY==2021').tail(10)\n```\n\n|            | DOY |   FY |\n| :--------- | --: | ---: |\n| 2021-12-16 | 355 | 2021 |\n| 2021-12-17 | 356 | 2021 |\n| 2021-12-18 | 357 | 2021 |\n| 2021-12-19 | 358 | 2021 |\n| 2021-12-20 | 359 | 2021 |\n| 2021-12-21 | 360 | 2021 |\n| 2021-12-22 | 361 | 2021 |\n| 2021-12-23 | 362 | 2021 |\n| 2021-12-24 | 363 | 2021 |\n| 2021-12-25 | 364 | 2021 |\n\nThis loop created a dataframe with the daily `pd.DatetimeIndex` and a few columns that specify where each calendar day falls in the fiscal year.\n\nWe can also add more features, like the workweek in the year, which fiscal quarter that day falls under, and more:\n\n```python\n# workweek in year\nresult['WW'] = ((result['DOY']-1) //7) + 1\n# fiscal quarter\nresult['FQ'] = np.minimum((result['WW']//13) + 1, 4)\n# workweek in quarter\nresult['WWinQ'] = result['WW'] - ((result['FQ']-1) * 13)\n# fiscal month\nresult['FM'] = ((result['FQ']-1)*3) + np.minimum(((result['WWinQ'] // 4)+1), 3)\n\n# Show the result\nresult.query('FY==2021').tail(10)\n```\n\n|            | DOY |   FY |  WW |  FQ | WWinQ |  FM |\n| :--------- | --: | ---: | --: | --: | ----: | --: |\n| 2021-12-16 | 355 | 2021 |  51 |   4 |    12 |  12 |\n| 2021-12-17 | 356 | 2021 |  51 |   4 |    12 |  12 |\n| 2021-12-18 | 357 | 2021 |  51 |   4 |    12 |  12 |\n| 2021-12-19 | 358 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-20 | 359 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-21 | 360 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-22 | 361 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-23 | 362 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-24 | 363 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-25 | 364 | 2021 |  52 |   4 |    13 |  12 |\n\n# Summary\n\nGreat! We can summarize the function a [public gist](https://gist.github.com/banditkings/735fe1885a442b3457d208060ac4b970).\n\nSo if you have a pretty clean fiscal calendar, `pandas` has you covered. But if you use a 4-4-5 calendar (aka 52/53 workweek calendar) then you'll mostly be building one from scratch. `pandas` _does_ help a little bit with finding the beginning and end dates of each fiscal year, which helps you avoid having to write your own logic to handle leap years and deciding which years have 52 workweeks instead of 53 workweeks.\n\n## References Used\n\n- [Pandas user guide on time series/date functionality](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)\n- [Pandas docs on `timedeltas`](https://pandas.pydata.org/pandas-docs/stable/user_guide/timedeltas.html)\n- [Pandas Reference Docs on Date offsets](https://pandas.pydata.org/docs/reference/offset_frequency.html#)\n- [Docs on Period objects](https://pandas.pydata.org/docs/reference/api/pandas.Period.html)\n- [Pandas frequency strings aka offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases)\n- [Pandas Info on the FY5253 offset](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.FY5253.html)\n","srcMarkdownNoYaml":"\n\n_Last run on pandas 1.1.3_\n\n# TLDR\n\n- Here's the [gist](https://gist.github.com/banditkings/735fe1885a442b3457d208060ac4b970)\n- Notebook versions: [[ipynb]](https://github.com/banditkings/random-python-examples/blob/main/time-series-python/pandas-time-functions.ipynb)[[html]](https://github.com/banditkings/random-python-examples/blob/main/time-series-python/pandas-time-functions.ipynb)\n\n# Fiscal Calendars Should Be Easy, Right?\n\nUnless your company's fiscal calendar lines up exactly with the calendar year, you'll inevitably encounter issues with custom fiscal calendars. Analysts will usually have some lookup table either in a spreadsheet or a friendly database table that they're trained to query and pull in every time someone asks: _'how did we perform this quarter compared to last quarter?'_\n\nBut what about making a lookup table _programmatically_, or what if you don't have a tidy lookup table handed to you? For example, let's say you work in a paper supplier and you have a table of forecasted supply and you need to match that data to demand that each customer sent over in spreadsheets. Now imagine each customer sent you demand according to their fiscal calendar. Welcome to hell!\n\n# Building Standard Fiscal Calendars in `pandas`\n\nSo what can you do in basic `pandas`? Well, if your fiscal calendar is the same as the calendar year, you're in luck.\n\n`pandas` has a variety of functions that let you create and manipulate date ranges that conform to a fiscal calendar that begins on January 1st of every year and ends on Dec 31st of every year, and where every quarter is exactly 3 calendar months long.\n\nWe can see an example of this built-in functionality if we use `pandas` to give us an array of the _last_ day in each quarter in 2021 using the `freq='Q'` parameter:\n\n```python\nimport datetime\nimport numpy as np\nimport pandas as pd\n\nstart = datetime.datetime(2021, 1, 1)\nend = datetime.datetime(2022, 1, 1)\n# Create a DatetimeIndex with freq='Q'\n# the 'Q' indicates the last day of each quarter\nts = pd.date_range(start, end, freq='Q')\nts\n```\n\nWhich returns an iterable `DatetimeIndex` object with a few extra parameters:\n\n```\nDatetimeIndex(['2021-03-31', '2021-06-30', '2021-09-30', '2021-12-31'], dtype='datetime64[ns]', freq='Q-DEC')\n```\n\nWe can use this index to create a dataframe with columns with various attributes, by converting this stuff to a `period` object:\n\n```python\ntp = ts.to_period()\n\npd.DataFrame(index=ts,\n             data={'quarter':tp.quarter,\n                   'fiscal_year':tp.qyear})\n```\n\n|            | quarter | fiscal_year |\n| :--------- | ------: | ----------: |\n| 2021-03-31 |       1 |        2021 |\n| 2021-06-30 |       2 |        2021 |\n| 2021-09-30 |       3 |        2021 |\n| 2021-12-31 |       4 |        2021 |\n\nHowever, what if you wanted to use `pandas` to handle fiscal calendars that aren't set to this standard? For example, let's say we have a fiscal calendar that starts on June 1st (i.e. Nike).\n\nNotice that the previous creation of a `pd.date_range` with `freq='Q'` created a DatetimeIndex with a freq of `'Q-DEC'`. While there's a list of ['frequency or offset aliases'](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases) there isn't much mention of what `'Q-DEC'` is except mentioned briefly in the [Pandas user guide](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#frequency-conversion-and-resampling-with-periodindex):\n\n> Many organizations define quarters relative to the month in which their fiscal year starts and ends. Thus, first quarter of 2011 could start in 2010 or a few months into 2011. Via anchored frequencies, pandas works for all quarterly frequencies `Q-JAN` through `Q-DEC`.\n\nSo in other words, the default quarter system `Q-DEC` (and `A-DEC`) means that it ends in December. So if we wanted to have a fiscal calendar that ends in May and starts in June 1st, we'd use `Q-MAY`:\n\n```python\nts = pd.date_range(start, end, freq='Q-MAY')\ntp = ts.to_period()\n\npd.DataFrame(index=ts, data={'quarter':tp.quarter, 'fiscal_year':tp.qyear})\n```\n\n|            | quarter | fiscal_year |\n| :--------- | ------: | ----------: |\n| 2021-02-28 |       3 |        2021 |\n| 2021-05-31 |       4 |        2021 |\n| 2021-08-31 |       1 |        2022 |\n| 2021-11-30 |       2 |        2022 |\n\nSo that was easy! And instead of creating the date range with just the end quarters, we can create a daily date range and then use the `to_period()` call to do the fiscal year translation for us, to create a _daily_ calendar lookup table:\n\n```python\n# create a DatetimeIndex with all days between 2021 and 2022\nts = pd.date_range(start='2021', end='2022', freq='D')\n\n# Create a PeriodIndex from the daily range with our new freq\ntp = ts.to_period(freq='Q-MAY')\ndf = pd.DataFrame(index=ts,\n                  data={'quarter':tp.quarter,\n                        'fiscal_year':tp.qyear})\ndf.tail()\n```\n\n|            | quarter | fiscal_year |\n| :--------- | ------: | ----------: |\n| 2021-12-28 |       3 |        2022 |\n| 2021-12-29 |       3 |        2022 |\n| 2021-12-30 |       3 |        2022 |\n| 2021-12-31 |       3 |        2022 |\n| 2022-01-01 |       3 |        2022 |\n\nWe can see that the correct fiscal year and fiscal quarters are represented. Nice!\n\n# 52/53 Workweek Calendars\n\nWhat if your fiscal calendar follows a [52/53-workweek calendar using the 4-4-5 quarter system](https://en.wikipedia.org/wiki/4–4–5_calendar)? I want to be able to use `pandas` methods on those, too!\n\nAn exhaustive search in `pandas` docs comes up with a custom DateOffset class that has the barest minimum in terms of [documentation](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.FY5253.html): `pd.tseries.offsets.FY5253`.\n\nWe can use the `pd.tseries.offsets.FY5253` DateOffset type to find the dates of the beginning of each fiscal year:\n\n```python\nvariation = 'last'\n\n# create an offset for the Intel fiscal calendar, which ends on the last Saturday of December\nyoffset = pd.tseries.offsets.FY5253(n=1, weekday=5, startingMonth=12, variation=variation)\n\n# use the offset to create a date range with intervals at each fiscal year beginning\nyoffset_range = pd.date_range('2020', periods=3, freq=yoffset)\nyoffset_range\n```\n\n```\nDatetimeIndex(['2020-12-26', '2021-12-25', '2022-12-31'], dtype='datetime64[ns]', freq='RE-L-DEC-SAT')\n```\n\nLet's take a look at the above result - we've generated a `DatetimeIndex` with the _last_ day of each fiscal year. In this case, we are telling `pandas` to create an offset using a 52/53 workweek calendar where the last day of the fiscal calendar lands on **the last (`variation='last'`) Saturday (`weekday=5`) in December (`month=12`)**. See [documentation](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.FY5253.html) for an explainer on the other parameters, and the 'nearest' variation.\n\nNotice the new `freq` string. Creating the timeseries offset object generates a new `freq` string that you can use for the `pd.date_range` function. However, unlike the previous examples you can't convert these to `Period` objects to get the quarter, month, etc (you can try it - it'll return an error).\n\nSo how can we use this to create a lookup table? We can do it manually with a loop and `pd.date_range`:\n\n```python\n# Create a '1 day' offset:\nd1 = pd.tseries.offsets.DateOffset(n = 1)\n\n# Specify the starting fiscal year\nyr = (yoffset_range[0] - pd.tseries.offsets.DateOffset(n=8)).year +1\n\n# iterate over each item in the date range we created earlier:\nresult = pd.DataFrame()\nfor i in yoffset_range:\n    # recall each item is a Timestamp that represents the first day of the fiscal year,\n    # so create a date_range from beginning to end of the fiscal year\n    current_range = pd.date_range(i+d1, i+yoffset, freq='D')\n    interim_df = pd.DataFrame(index = current_range)\n    # day of year\n    interim_df['DOY'] = (current_range-current_range[0]).days +1\n    # fiscal year\n    interim_df['FY'] = yr\n    result = result.append(interim_df)\n    yr += 1\n\n# See what we get:\nresult.query('FY==2021').tail(10)\n```\n\n|            | DOY |   FY |\n| :--------- | --: | ---: |\n| 2021-12-16 | 355 | 2021 |\n| 2021-12-17 | 356 | 2021 |\n| 2021-12-18 | 357 | 2021 |\n| 2021-12-19 | 358 | 2021 |\n| 2021-12-20 | 359 | 2021 |\n| 2021-12-21 | 360 | 2021 |\n| 2021-12-22 | 361 | 2021 |\n| 2021-12-23 | 362 | 2021 |\n| 2021-12-24 | 363 | 2021 |\n| 2021-12-25 | 364 | 2021 |\n\nThis loop created a dataframe with the daily `pd.DatetimeIndex` and a few columns that specify where each calendar day falls in the fiscal year.\n\nWe can also add more features, like the workweek in the year, which fiscal quarter that day falls under, and more:\n\n```python\n# workweek in year\nresult['WW'] = ((result['DOY']-1) //7) + 1\n# fiscal quarter\nresult['FQ'] = np.minimum((result['WW']//13) + 1, 4)\n# workweek in quarter\nresult['WWinQ'] = result['WW'] - ((result['FQ']-1) * 13)\n# fiscal month\nresult['FM'] = ((result['FQ']-1)*3) + np.minimum(((result['WWinQ'] // 4)+1), 3)\n\n# Show the result\nresult.query('FY==2021').tail(10)\n```\n\n|            | DOY |   FY |  WW |  FQ | WWinQ |  FM |\n| :--------- | --: | ---: | --: | --: | ----: | --: |\n| 2021-12-16 | 355 | 2021 |  51 |   4 |    12 |  12 |\n| 2021-12-17 | 356 | 2021 |  51 |   4 |    12 |  12 |\n| 2021-12-18 | 357 | 2021 |  51 |   4 |    12 |  12 |\n| 2021-12-19 | 358 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-20 | 359 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-21 | 360 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-22 | 361 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-23 | 362 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-24 | 363 | 2021 |  52 |   4 |    13 |  12 |\n| 2021-12-25 | 364 | 2021 |  52 |   4 |    13 |  12 |\n\n# Summary\n\nGreat! We can summarize the function a [public gist](https://gist.github.com/banditkings/735fe1885a442b3457d208060ac4b970).\n\nSo if you have a pretty clean fiscal calendar, `pandas` has you covered. But if you use a 4-4-5 calendar (aka 52/53 workweek calendar) then you'll mostly be building one from scratch. `pandas` _does_ help a little bit with finding the beginning and end dates of each fiscal year, which helps you avoid having to write your own logic to handle leap years and deciding which years have 52 workweeks instead of 53 workweeks.\n\n## References Used\n\n- [Pandas user guide on time series/date functionality](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)\n- [Pandas docs on `timedeltas`](https://pandas.pydata.org/pandas-docs/stable/user_guide/timedeltas.html)\n- [Pandas Reference Docs on Date offsets](https://pandas.pydata.org/docs/reference/offset_frequency.html#)\n- [Docs on Period objects](https://pandas.pydata.org/docs/reference/api/pandas.Period.html)\n- [Pandas frequency strings aka offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases)\n- [Pandas Info on the FY5253 offset](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.FY5253.html)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"2022-02-20-fiscal-5253-workweek-calendars-in-pandas.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.52","theme":{"light":"cosmo"},"title-block-banner":true,"title":"Making Custom Fiscal 52/53 Workweek Calendars in Pandas","date":"2022-02-20","tags":["python"],"categories":["modeling"],"summary":"How to build custom financial calendars that have 52 or 53 workweeks in a fiscal year (aka the 4-4-5 calendar) using `pandas`","canonicalUrl":"https://www.nelsontang.com/blog/fiscal-5253-workweek-calendar-in-pandas"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}