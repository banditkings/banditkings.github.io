{"title":"A SQL to Julia DataFrames Cheatsheet","markdown":{"yaml":{"title":"A SQL to Julia DataFrames Cheatsheet","date":"2022-03-27","categories":["julia","modeling"],"summary":"What would common SQL expressions look like in Julia DataFrames and Julia DataFramesMeta?","aliases":["/SQL-to-Julia"],"canonicalUrl":"https://www.nelsontang.com/blog/2022-03-27-sql-to-julia"},"headingText":"Overview","containsRefs":false,"markdown":"\n\nA SQL to Julia DataFrames dictionary using DataFrames and DataFramesMeta. In general, I use DataFramesMeta since it abstracts away some lower level nuance and it makes for a tidier workflow when I'm constructing queries.\n\n\n## Querying in `DataFrames` and `DataFramesMeta`\n\n| SQL Clause                                             | DataFrames Equivalent                                           | DataFramesMeta Equivalent                                                                                                         |\n| ------------------------------------------------------ | --------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |\n| `SELECT`                                               | `select`                                                        | `@select`                                                                                                                         |\n| `WHERE`                                                | `subset(df, :colnm => ByRow(x -> x>1))`                         | `@rsubset(df, :colnm > 1)`                                                                                                        |\n| `LIKE`                                                 | `subset(df, :colnm=>ByRow(x -> occursin(r\"string\", x)))`        | `@rsubset(df, occursin(r\"string\", :colnm))`                                                                                       |\n| `GROUP BY`                                             | `gd = groupby(df, :colnm)`<br></br>`combine(gd, :colnm=>sum)`   | `gd = groupby(df, :colnm)`<br></br>`@combine(gd, :newcol=sum(:colnm))`<br></br>or<br></br> `@by(df, :colnm, :newcol=sum(:colnm))` |\n| `SUM(colnm) OVER (PARTITION BY other_colnm) AS newcol` | `gd = groupby(df, :colnm)`<br></br>`transform(gd, :colnm=>sum)` | `gd = groupby(df, :colnm)`<br></br>`@transform(gd, :newcol=sum(:colnm))`                                                          |\n| `ORDER BY colnm ASC`                                   | `sort(df, :colnm)`                                              | `@orderby(df, :colnm)`                                                                                                            |\n| `ORDER BY colnm DESC`                                  | `sort(df, :colnm, rev=true)`                                    | `@orderby(df, sort(:colnm, rev=true)`                                                                                             |\n\n## Joins\n\n| SQL Clause                                                                 | DataFrames Equivalent                                                            |\n| -------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |\n| `INNER JOIN`                                                               | `innerjoin(df, df2, on=:colnm)`<br></br>`innerjoin(df, df2, on=[:left=>:right])` |\n| `LEFT JOIN`                                                                | `leftjoin(df, df2, on=:colnm)`<br></br>`leftjoin(df, df2, on=[:left=>:right])`   |\n| `RIGHT JOIN`                                                               | `rightjoin(df, df2, on=:colnm)`<br></br>`rightjoin(df, df2, on=[:left=>:right])` |\n| `OUTER JOIN`                                                               | `outerjoin(df, df2, on=:colnm)`<br></br>`outerjoin(df, df2, on=[:left=>:right])` |\n| `SELECT * FROM table1, table2` <br></br>aka cartesian product or crossjoin | `crossjoin`                                                                      |\n\n# A Worked Example\n\n## The Dataset\n\nWe'll manually create a dataset of employees `df`:\n\n```julia\nusing CSV, DataFramesMeta, Statistics, Dates\n\n# DataFrame(column=data)\ndf = DataFrame(id=1:8,\n               first_name=[\"Michael\", \"Dwight\", \"Angela\", \"Jim\", \"Pam\", \"Oscar\", \"Meredith\", \"Creed\"],\n               last_name=[\"Scott\", \"Schrute\", \"Martin\", \"Halpert\", \"Beesly\", \"Nunez\", \"Palmer\", \"Bratton\"],\n               department=[\"Management & Admin\", \"Sales\", \"Accounting\", \"Sales\", \"Management & Admin\", \"Accounting\",\n                           \"Purchasing\", \"Purchasing\"],\n               salary=[5100, 4200, 3750, 4300, 2200, 3400, 3300, 3200])\n\n8×5 DataFrame\n Row │ id     first_name  last_name  department          salary\n     │ Int64  String      String     String              Int64\n─────┼──────────────────────────────────────────────────────────\n   1 │     1  Michael     Scott      Management & Admin    5100\n   2 │     2  Dwight      Schrute    Sales                 4200\n   3 │     3  Angela      Martin     Accounting            3750\n   4 │     4  Jim         Halpert    Sales                 4300\n   5 │     5  Pam         Beesly     Management & Admin    2200\n   6 │     6  Oscar       Nunez      Accounting            3400\n   7 │     7  Meredith    Palmer     Purchasing            3300\n   8 │     8  Creed       Bratton    Purchasing            3200\n```\n\nLet's create a sales database called `db_sales` with client information (thanks to [this site](https://theoffice.fandom.com/wiki/Clients_of_Dunder_Mifflin))\n\n```julia\n# Parse dates as Date objects\ndates = [\"1-2-2006\", \"1-29-2006\", \"2-1-2006\", \"2-14-2006\", \"3-1-2006\", \"3-20-2006\"]\ndates = parse.(Date, dates, dateformat\"m-d-y\")\n\ndb_sales = DataFrame(id=1:6,\n                     transaction_date=dates,\n                     employee_id=[4, 2, 4, 2, 4, 2],\n                     quantity=[100, 500, 600, 200, 400, 250],\n                     customer=[\"Dunmore High School\", \"Harper Collins\", \"Blue Cross of Pennsylvania\",\n                                \"Apex Technology\", \"Blue Cross of Pennsylvania\",\n                                \"Stone, Cooper, and Grandy: Attorneys at Law\"])\n\n6×5 DataFrame\n Row │ id     transaction_date  employee_id  quantity  customer\n     │ Int64  Date              Int64        Int64     String\n─────┼───────────────────────────────────────────────────────────────────────────────────\n   1 │     1  2006-01-02                  4       100  Dunmore High School\n   2 │     2  2006-01-29                  2       500  Harper Collins\n   3 │     3  2006-02-01                  4       600  Blue Cross of Pennsylvania\n   4 │     4  2006-02-14                  2       200  Apex Technology\n   5 │     5  2006-03-01                  4       400  Blue Cross of Pennsylvania\n   6 │     6  2006-03-20                  2       250  Stone, Cooper, and Grandy: Attor…\n```\n\n## Subsetting Rows\n\nSubsetting rows is possible in base `DataFrames`, but the syntax in `DataFramesMeta` is easier for beginners to follow. The special `@rsubset` macro saves on having to write anonymous functions so it's one less syntactical thing to keep typing every time.\n\n```julia\n#DataFrames\nsubset(df, :department => ByRow(x -> occursin(\"Admin\", x)))\n\n#DataFramesMeta\n@rsubset(df, occursin(\"Admin\", :department))\n\n2×5 DataFrame\n Row │ id     first_name  last_name  department          salary\n     │ Int64  String      String     String              Int64\n─────┼──────────────────────────────────────────────────────────\n   1 │     1  Michael     Scott      Management & Admin    5100\n   2 │     5  Pam         Beesly     Management & Admin    2200\n```\n\n### Matching Text\n\nWhat if you want to do some string matching with wildcards, i.e. SQL `WHERE` clause with the `LIKE` or `%` operator?\n\nWe can use the `occursin()` function and pass it as an argument to `@rsubset`, like:\n\n```julia\n#DataFrames\nsubset(df, :department => ByRow(x -> occursin(\"Admin\", x)))\n\n#DataFramesMeta\n@rsubset(df, occursin(\"Admin\", :department))\n\n2×5 DataFrame\n Row │ id     first_name  last_name  department          salary\n     │ Int64  String      String     String              Int64\n─────┼──────────────────────────────────────────────────────────\n   1 │     1  Michael     Scott      Management & Admin    5100\n   2 │     5  Pam         Beesly     Management & Admin    2200\n```\n\nAdding the `r` in front of the string lets you use regex to use wildcards and more complex string matching criteria.\n\n## Aggregation\n\ni.e. `GROUP BY Column` and `SUM(column)`\n\nFor regular `GROUP BY` you first use `groupby()` and then either `combine` or `@combine`, or you can use the `@by` function as shorthand.\n\n### Grouping with `@by`\n\n```julia\n@by(df, :department,\n        :\"Average Salary\" = mean(:salary),\n        :count=length(:salary))\n\n4×2 DataFrame\n Row │ department          Average Salary\n     │ String              Float64\n─────┼────────────────────────────────────\n   1 │ Management & Admin          3650.0\n   2 │ Sales                       4250.0\n   3 │ Accounting                  3575.0\n   4 │ Purchasing                  3250.0\n```\n\n### Grouping with `combine` and `@combine`\n\n```julia\ngd = groupby(df, :department)\n#DataFrames\ncombine(gd, :salary => mean => :\"Average Salary\",\n            :department => length => :count)\n\n#DataFramesMeta\n@combine(gd, :\"Average Salary\" = mean(:salary),\n             :count = length(:department))\n\n4×2 DataFrame\n Row │ department          Average Salary\n     │ String              Float64\n─────┼────────────────────────────────────\n   1 │ Management & Admin          3650.0\n   2 │ Sales                       4250.0\n   3 │ Accounting                  3575.0\n   4 │ Purchasing                  3250.0\n```\n\n## Window Functions with `@transform`\n\nIn SQL:\n\n```sql\nAVG(colnm) OVER (PARTITION BY other_colnm) AS newcol\n```\n\ni.e. the `PARTITION BY` clause, similar to groupby but it returns a value for each row in your table after doing the aggregations in each partition.\n\nIn Julia, you can use the `@transform` macro to do this after grouping.\n\n```julia\n# Example: add a column that\ngd = groupby(df, :department)\n#DataFrames\ntransform(gd, :salary => mean => :\"avg_dept_salary\")\n\n#DataFramesMeta\n@transform(gd, :\"avg_dept_salary\"=mean(:salary))\n\n8×6 DataFrame\n Row │ id     first_name  last_name  department          salary  avg_dept_salary\n     │ Int64  String      String     String              Int64   Float64\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     1  Michael     Scott      Management & Admin    5100          3650.0\n   2 │     2  Dwight      Schrute    Sales                 4200          4250.0\n   3 │     3  Angela      Martin     Accounting            3750          3575.0\n   4 │     4  Jim         Halpert    Sales                 4300          4250.0\n   5 │     5  Pam         Beesly     Management & Admin    2200          3650.0\n   6 │     6  Oscar       Nunez      Accounting            3400          3575.0\n   7 │     7  Meredith    Palmer     Purchasing            3300          3250.0\n   8 │     8  Creed       Bratton    Purchasing            3200          3250.0\n```\n\nAnd we see indeed that we have the same number of rows as the initial dataset.\n\n## Putting together a query with `@chain`\n\n```julia\nsales = @chain db_sales begin\n    groupby(:employee_id)\n    @combine(:total_quantity=sum(:quantity),\n             :number_of_customers=length(:customer))\nend\n\nresult = @chain df begin\n                @select(:id, :first_name, :last_name, :department)\n                @rsubset(:department==\"Sales\")\n                leftjoin(sales, on=[:id=>:employee_id])\n                @orderby(sort(:total_quantity, rev=true))  # descending\n          end\n\n2×6 DataFrame\n Row │ id     first_name  last_name  department  total_quantity  number_of_customers\n     │ Int64  String      String     String      Int64?          Int64?\n─────┼───────────────────────────────────────────────────────────────────────────────\n   1 │     4  Jim         Halpert    Sales                 1100                    3\n   2 │     2  Dwight      Schrute    Sales                  950                    3\n```\n\n# Alternative: Use DuckDB\n\nAnother amazing alternative is to use [`DuckDB`](https://duckdb.org/docs/api/julia) to query dataframes, CSV files, parquet files, etc directly with SQL.\n\nAssuming we had the dataframes created above, we'd query it with SQL with a few lines:\n\n```julia\nusing DuckDB\n\n# create a new in-memory dabase\ncon = DBInterface.connect(DuckDB.DB)\n\n# register it as a view in the database\nDuckDB.register_data_frame(con, df, \"my_df\")\n\nqueryStr = \"\"\"\nSELECT\nfirst_name\n, last_name\n, department\n, salary\n, AVG(salary) OVER (PARTITION BY department) AS avg_dept_salary\nFROM my_df\n\"\"\"\n\n# run a SQL query over the DataFrame\nresults = DBInterface.execute(con, queryStr)\nprint(results)\n\n# 8×5 DataFrame\n#  Row │ first_name  last_name  department          salary  avg_dept_salary\n#      │ String?     String?    String?             Int64?  Float64?\n# ─────┼────────────────────────────────────────────────────────────────────\n#    1 │ Angela      Martin     Accounting            3750           3575.0\n#    2 │ Oscar       Nunez      Accounting            3400           3575.0\n#    3 │ Michael     Scott      Management & Admin    5100           3650.0\n#    4 │ Pam         Beesly     Management & Admin    2200           3650.0\n#    5 │ Meredith    Palmer     Purchasing            3300           3250.0\n#    6 │ Creed       Bratton    Purchasing            3200           3250.0\n#    7 │ Dwight      Schrute    Sales                 4200           4250.0\n#    8 │ Jim         Halpert    Sales                 4300           4250.0\n```\n","srcMarkdownNoYaml":"\n\nA SQL to Julia DataFrames dictionary using DataFrames and DataFramesMeta. In general, I use DataFramesMeta since it abstracts away some lower level nuance and it makes for a tidier workflow when I'm constructing queries.\n\n# Overview\n\n## Querying in `DataFrames` and `DataFramesMeta`\n\n| SQL Clause                                             | DataFrames Equivalent                                           | DataFramesMeta Equivalent                                                                                                         |\n| ------------------------------------------------------ | --------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |\n| `SELECT`                                               | `select`                                                        | `@select`                                                                                                                         |\n| `WHERE`                                                | `subset(df, :colnm => ByRow(x -> x>1))`                         | `@rsubset(df, :colnm > 1)`                                                                                                        |\n| `LIKE`                                                 | `subset(df, :colnm=>ByRow(x -> occursin(r\"string\", x)))`        | `@rsubset(df, occursin(r\"string\", :colnm))`                                                                                       |\n| `GROUP BY`                                             | `gd = groupby(df, :colnm)`<br></br>`combine(gd, :colnm=>sum)`   | `gd = groupby(df, :colnm)`<br></br>`@combine(gd, :newcol=sum(:colnm))`<br></br>or<br></br> `@by(df, :colnm, :newcol=sum(:colnm))` |\n| `SUM(colnm) OVER (PARTITION BY other_colnm) AS newcol` | `gd = groupby(df, :colnm)`<br></br>`transform(gd, :colnm=>sum)` | `gd = groupby(df, :colnm)`<br></br>`@transform(gd, :newcol=sum(:colnm))`                                                          |\n| `ORDER BY colnm ASC`                                   | `sort(df, :colnm)`                                              | `@orderby(df, :colnm)`                                                                                                            |\n| `ORDER BY colnm DESC`                                  | `sort(df, :colnm, rev=true)`                                    | `@orderby(df, sort(:colnm, rev=true)`                                                                                             |\n\n## Joins\n\n| SQL Clause                                                                 | DataFrames Equivalent                                                            |\n| -------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |\n| `INNER JOIN`                                                               | `innerjoin(df, df2, on=:colnm)`<br></br>`innerjoin(df, df2, on=[:left=>:right])` |\n| `LEFT JOIN`                                                                | `leftjoin(df, df2, on=:colnm)`<br></br>`leftjoin(df, df2, on=[:left=>:right])`   |\n| `RIGHT JOIN`                                                               | `rightjoin(df, df2, on=:colnm)`<br></br>`rightjoin(df, df2, on=[:left=>:right])` |\n| `OUTER JOIN`                                                               | `outerjoin(df, df2, on=:colnm)`<br></br>`outerjoin(df, df2, on=[:left=>:right])` |\n| `SELECT * FROM table1, table2` <br></br>aka cartesian product or crossjoin | `crossjoin`                                                                      |\n\n# A Worked Example\n\n## The Dataset\n\nWe'll manually create a dataset of employees `df`:\n\n```julia\nusing CSV, DataFramesMeta, Statistics, Dates\n\n# DataFrame(column=data)\ndf = DataFrame(id=1:8,\n               first_name=[\"Michael\", \"Dwight\", \"Angela\", \"Jim\", \"Pam\", \"Oscar\", \"Meredith\", \"Creed\"],\n               last_name=[\"Scott\", \"Schrute\", \"Martin\", \"Halpert\", \"Beesly\", \"Nunez\", \"Palmer\", \"Bratton\"],\n               department=[\"Management & Admin\", \"Sales\", \"Accounting\", \"Sales\", \"Management & Admin\", \"Accounting\",\n                           \"Purchasing\", \"Purchasing\"],\n               salary=[5100, 4200, 3750, 4300, 2200, 3400, 3300, 3200])\n\n8×5 DataFrame\n Row │ id     first_name  last_name  department          salary\n     │ Int64  String      String     String              Int64\n─────┼──────────────────────────────────────────────────────────\n   1 │     1  Michael     Scott      Management & Admin    5100\n   2 │     2  Dwight      Schrute    Sales                 4200\n   3 │     3  Angela      Martin     Accounting            3750\n   4 │     4  Jim         Halpert    Sales                 4300\n   5 │     5  Pam         Beesly     Management & Admin    2200\n   6 │     6  Oscar       Nunez      Accounting            3400\n   7 │     7  Meredith    Palmer     Purchasing            3300\n   8 │     8  Creed       Bratton    Purchasing            3200\n```\n\nLet's create a sales database called `db_sales` with client information (thanks to [this site](https://theoffice.fandom.com/wiki/Clients_of_Dunder_Mifflin))\n\n```julia\n# Parse dates as Date objects\ndates = [\"1-2-2006\", \"1-29-2006\", \"2-1-2006\", \"2-14-2006\", \"3-1-2006\", \"3-20-2006\"]\ndates = parse.(Date, dates, dateformat\"m-d-y\")\n\ndb_sales = DataFrame(id=1:6,\n                     transaction_date=dates,\n                     employee_id=[4, 2, 4, 2, 4, 2],\n                     quantity=[100, 500, 600, 200, 400, 250],\n                     customer=[\"Dunmore High School\", \"Harper Collins\", \"Blue Cross of Pennsylvania\",\n                                \"Apex Technology\", \"Blue Cross of Pennsylvania\",\n                                \"Stone, Cooper, and Grandy: Attorneys at Law\"])\n\n6×5 DataFrame\n Row │ id     transaction_date  employee_id  quantity  customer\n     │ Int64  Date              Int64        Int64     String\n─────┼───────────────────────────────────────────────────────────────────────────────────\n   1 │     1  2006-01-02                  4       100  Dunmore High School\n   2 │     2  2006-01-29                  2       500  Harper Collins\n   3 │     3  2006-02-01                  4       600  Blue Cross of Pennsylvania\n   4 │     4  2006-02-14                  2       200  Apex Technology\n   5 │     5  2006-03-01                  4       400  Blue Cross of Pennsylvania\n   6 │     6  2006-03-20                  2       250  Stone, Cooper, and Grandy: Attor…\n```\n\n## Subsetting Rows\n\nSubsetting rows is possible in base `DataFrames`, but the syntax in `DataFramesMeta` is easier for beginners to follow. The special `@rsubset` macro saves on having to write anonymous functions so it's one less syntactical thing to keep typing every time.\n\n```julia\n#DataFrames\nsubset(df, :department => ByRow(x -> occursin(\"Admin\", x)))\n\n#DataFramesMeta\n@rsubset(df, occursin(\"Admin\", :department))\n\n2×5 DataFrame\n Row │ id     first_name  last_name  department          salary\n     │ Int64  String      String     String              Int64\n─────┼──────────────────────────────────────────────────────────\n   1 │     1  Michael     Scott      Management & Admin    5100\n   2 │     5  Pam         Beesly     Management & Admin    2200\n```\n\n### Matching Text\n\nWhat if you want to do some string matching with wildcards, i.e. SQL `WHERE` clause with the `LIKE` or `%` operator?\n\nWe can use the `occursin()` function and pass it as an argument to `@rsubset`, like:\n\n```julia\n#DataFrames\nsubset(df, :department => ByRow(x -> occursin(\"Admin\", x)))\n\n#DataFramesMeta\n@rsubset(df, occursin(\"Admin\", :department))\n\n2×5 DataFrame\n Row │ id     first_name  last_name  department          salary\n     │ Int64  String      String     String              Int64\n─────┼──────────────────────────────────────────────────────────\n   1 │     1  Michael     Scott      Management & Admin    5100\n   2 │     5  Pam         Beesly     Management & Admin    2200\n```\n\nAdding the `r` in front of the string lets you use regex to use wildcards and more complex string matching criteria.\n\n## Aggregation\n\ni.e. `GROUP BY Column` and `SUM(column)`\n\nFor regular `GROUP BY` you first use `groupby()` and then either `combine` or `@combine`, or you can use the `@by` function as shorthand.\n\n### Grouping with `@by`\n\n```julia\n@by(df, :department,\n        :\"Average Salary\" = mean(:salary),\n        :count=length(:salary))\n\n4×2 DataFrame\n Row │ department          Average Salary\n     │ String              Float64\n─────┼────────────────────────────────────\n   1 │ Management & Admin          3650.0\n   2 │ Sales                       4250.0\n   3 │ Accounting                  3575.0\n   4 │ Purchasing                  3250.0\n```\n\n### Grouping with `combine` and `@combine`\n\n```julia\ngd = groupby(df, :department)\n#DataFrames\ncombine(gd, :salary => mean => :\"Average Salary\",\n            :department => length => :count)\n\n#DataFramesMeta\n@combine(gd, :\"Average Salary\" = mean(:salary),\n             :count = length(:department))\n\n4×2 DataFrame\n Row │ department          Average Salary\n     │ String              Float64\n─────┼────────────────────────────────────\n   1 │ Management & Admin          3650.0\n   2 │ Sales                       4250.0\n   3 │ Accounting                  3575.0\n   4 │ Purchasing                  3250.0\n```\n\n## Window Functions with `@transform`\n\nIn SQL:\n\n```sql\nAVG(colnm) OVER (PARTITION BY other_colnm) AS newcol\n```\n\ni.e. the `PARTITION BY` clause, similar to groupby but it returns a value for each row in your table after doing the aggregations in each partition.\n\nIn Julia, you can use the `@transform` macro to do this after grouping.\n\n```julia\n# Example: add a column that\ngd = groupby(df, :department)\n#DataFrames\ntransform(gd, :salary => mean => :\"avg_dept_salary\")\n\n#DataFramesMeta\n@transform(gd, :\"avg_dept_salary\"=mean(:salary))\n\n8×6 DataFrame\n Row │ id     first_name  last_name  department          salary  avg_dept_salary\n     │ Int64  String      String     String              Int64   Float64\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     1  Michael     Scott      Management & Admin    5100          3650.0\n   2 │     2  Dwight      Schrute    Sales                 4200          4250.0\n   3 │     3  Angela      Martin     Accounting            3750          3575.0\n   4 │     4  Jim         Halpert    Sales                 4300          4250.0\n   5 │     5  Pam         Beesly     Management & Admin    2200          3650.0\n   6 │     6  Oscar       Nunez      Accounting            3400          3575.0\n   7 │     7  Meredith    Palmer     Purchasing            3300          3250.0\n   8 │     8  Creed       Bratton    Purchasing            3200          3250.0\n```\n\nAnd we see indeed that we have the same number of rows as the initial dataset.\n\n## Putting together a query with `@chain`\n\n```julia\nsales = @chain db_sales begin\n    groupby(:employee_id)\n    @combine(:total_quantity=sum(:quantity),\n             :number_of_customers=length(:customer))\nend\n\nresult = @chain df begin\n                @select(:id, :first_name, :last_name, :department)\n                @rsubset(:department==\"Sales\")\n                leftjoin(sales, on=[:id=>:employee_id])\n                @orderby(sort(:total_quantity, rev=true))  # descending\n          end\n\n2×6 DataFrame\n Row │ id     first_name  last_name  department  total_quantity  number_of_customers\n     │ Int64  String      String     String      Int64?          Int64?\n─────┼───────────────────────────────────────────────────────────────────────────────\n   1 │     4  Jim         Halpert    Sales                 1100                    3\n   2 │     2  Dwight      Schrute    Sales                  950                    3\n```\n\n# Alternative: Use DuckDB\n\nAnother amazing alternative is to use [`DuckDB`](https://duckdb.org/docs/api/julia) to query dataframes, CSV files, parquet files, etc directly with SQL.\n\nAssuming we had the dataframes created above, we'd query it with SQL with a few lines:\n\n```julia\nusing DuckDB\n\n# create a new in-memory dabase\ncon = DBInterface.connect(DuckDB.DB)\n\n# register it as a view in the database\nDuckDB.register_data_frame(con, df, \"my_df\")\n\nqueryStr = \"\"\"\nSELECT\nfirst_name\n, last_name\n, department\n, salary\n, AVG(salary) OVER (PARTITION BY department) AS avg_dept_salary\nFROM my_df\n\"\"\"\n\n# run a SQL query over the DataFrame\nresults = DBInterface.execute(con, queryStr)\nprint(results)\n\n# 8×5 DataFrame\n#  Row │ first_name  last_name  department          salary  avg_dept_salary\n#      │ String?     String?    String?             Int64?  Float64?\n# ─────┼────────────────────────────────────────────────────────────────────\n#    1 │ Angela      Martin     Accounting            3750           3575.0\n#    2 │ Oscar       Nunez      Accounting            3400           3575.0\n#    3 │ Michael     Scott      Management & Admin    5100           3650.0\n#    4 │ Pam         Beesly     Management & Admin    2200           3650.0\n#    5 │ Meredith    Palmer     Purchasing            3300           3250.0\n#    6 │ Creed       Bratton    Purchasing            3200           3250.0\n#    7 │ Dwight      Schrute    Sales                 4200           4250.0\n#    8 │ Jim         Halpert    Sales                 4300           4250.0\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"2022-03-27-sql-to-julia.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.52","theme":{"light":"cosmo"},"title-block-banner":true,"title":"A SQL to Julia DataFrames Cheatsheet","date":"2022-03-27","categories":["julia","modeling"],"summary":"What would common SQL expressions look like in Julia DataFrames and Julia DataFramesMeta?","aliases":["/SQL-to-Julia"],"canonicalUrl":"https://www.nelsontang.com/blog/2022-03-27-sql-to-julia"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}