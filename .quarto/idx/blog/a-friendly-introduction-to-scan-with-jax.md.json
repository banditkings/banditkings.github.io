{"title":"A friendly introduction to scan with JAX","markdown":{"yaml":{"title":"A friendly introduction to scan with JAX","date":"2023-12-29","categories":["python"],"draft":false,"summary":"A friendly introduction to `scan` with JAX and numpyro","images":["/static/images/scan_jax/scan_components.png","/static/images/scan_jax/scan.gif","/static/images/scan_jax/scan_fig1.png","/static/images/scan_jax/scan_fig2.png","/static/images/scan_jax/scan_fig3.png"],"layout":"PostLayout"},"headingText":"Learning `scan` with `jax` and `numpyro`","containsRefs":false,"markdown":"\n\n\nLearning `scan` - it's all over the `numpyro` [time series examples](https://num.pyro.ai/en/stable/examples/holt_winters.html) so if I want to implement time series in `numpyro` from scratch, I'll need to better understand it.\n\nIn the context of time series models, `scan` is helpful because it allows us to iterate over sequences (without a cumbersome `for` loop) while maintaining state across each iteration.\n\n## Elements of a `scan`\n\nFirst, let's break down an example `scan` function into its' components:\n\n![img](/static/images/scan_jax/scan_components.png)\n\n# Trivial Example - Cumulative Sum\n\n- [From The Differential Programming Tutorial - Loopy Carry, by Eric Ma](https://ericmjl.github.io/dl-workshop/02-jax-idioms/02-loopy-carry.html)\n\nWe'll start with the cumsum example from [From The Differential Programming Tutorial - Loopy Carry, by Eric Ma](https://ericmjl.github.io/dl-workshop/02-jax-idioms/02-loopy-carry.html). We can implement a cumsum with a `for` loop like:\n\n```python\nfrom jax import random\nimport jax.numpy as jnp\n\n# xs\nxs = jnp.array([1, 2, 3, 5, 7, 11, 13, 17])\n\nresult = []\ncumsum = 0\nfor el in xs:\n    cumsum += el\n    result.append(cumsum)\njnp.array(result)\n```\n\n```\nArray([ 1,  3,  6, 11, 18, 29, 42, 59], dtype=int32)\n```\n\nNow, instead of a loop, we rewrite it with `jax.lax.scan`:\n\n```python\nfrom jax import lax\n\ndef cumsum(cumsum, el):\n    \"\"\"\n    Parameters\n    ----------\n    cumsum\n        The result from the previous loop, aka the 'carried over' result\n    el\n        The current element in the sequence in `xs`\n    \"\"\"\n    cumsum += el\n    return cumsum, cumsum # ('carryover', 'accumulated')\n\ninit_sum = 0\nfinal, result = lax.scan(cumsum, init_sum, xs)\nprint(final)\nprint(result)\n```\n\n```\n59\n[ 1  3  6 11 18 29 42 59]\n```\n\nWe see that `lax.scan` returned two things:\n\n- The first item is the latest value of the carried value `cumsum`\n- The second item being returned is an array where each iteration appended the latest value of `cumsum` to the end.\n\nTo make it a little more concrete, here's a GIF that steps through each iteration:\n\n![img](/static/images/scan_jax/scan.gif)\n\nSee that the scanned function returns two items: the first goes back into the loop while the second is appended to an array that acts as a 'running tally' of values from each iteration. You can also pass `None` here if you don't need it.\n\n## Trivial Example 2: A little more of the `scan` function with compounding interest\n\nThe first two parameters in the input function can have arbitrary names but **their order matters**. The first item is the 'carried over value', aka the `carry`. The second item is the current element in the `xs` input array.\n\nSimilarly the input function must have two outputs. The first output becomes the new 'carried over value' that will feed back into the input function, while the second output gets appended to an output `jax` array.\n\nLet's have a concrete example in which we calculate compounded interest for a $100 investment with a 4% interest rate:\n\n```python\n# Define the input function to apply at each time step\ndef interest_growth(value, x):\n    value = value * 1.04\n    return value, value # ('carried over value', 'accumulated array')\n\n# Define the initial state and input sequence\ninit_state = 100.0\nT = jnp.array([1, 2, 3, 4, 5])\nT = jnp.arange(1, 30)\n\n# Apply the scan function\nfinal_state, results = lax.scan(f=interest_growth, init=init_state, xs=T)\n\nprint(final_state)\nprint(results)\n```\n\n```\n311.8648\n[104.       108.159996 112.48639  116.98584  121.66527  126.531876\n 131.59314  136.85686  142.33113  148.02437  153.94534  160.10315\n 166.50726  173.16754  180.09424  187.298    194.78992  202.58151\n 210.68477  219.11215  227.87663  236.99168  246.47134  256.3302\n 266.5834   277.24673  288.33658  299.87003  311.8648  ]\n```\n\n![img](/static/images/scan_jax/scan_fig1.png)\n\nAnd we see the effect of the interest compounding over time.\n\n## Trivial Example 3: `scan` in `numpyro` to sample from a distribution\n\nAnd what I'm really interested in is learning `scan` in the context of doing time series in `numpyro`.\n\n`numpyro` has it's own (experimental) implementation of `scan` which allows us to iteratively sample from `numpyro` primitives like `numpyro.distributions`.\n\nHere's a simple example of a random walk:\n\n$$\ny_{t+1} = y_t + \\epsilon, \\quad \\epsilon \\sim \\mathcal{N}(0,1)\n$$\n\nOr, equivalently:\n\n$$\n\\begin{aligned}\ny_t &= \\mu_t\\\\\n\\mu_{t+1} &= \\mu_t + \\epsilon_\\mu, \\quad \\epsilon_\\mu \\sim \\mathcal{N}(0, 1)\\\\\n\\end{aligned}\n$$\n\nWe need to use `scan` because each subsequent value of $\\mu_{t+1}$ depends on its previous value $\\mu_{t}$.\n\nTo do this within a `scan` we'll also need to introduce an [effect handler](https://num.pyro.ai/en/stable/handlers.html#seed): `numpyro.handlers.seed` and run the `scan` function within that context.\n\n```python\n# Import libraries\nimport numpyro\nfrom numpyro.contrib.control_flow import scan\nimport numpyro.distributions as dist\nimport matplotlib.pyplot as plt\n\n# Define our random walk function as an input into `scan`\ndef random_walk(value, x):\n    value = numpyro.sample('x', dist.Normal(value, 1.))\n    # Which is the same as if we were very explicit:\n    # value = value + numpyro.sample('x', dist.Normal(0, 1.))\n    return value, value\n\ninit_0 = 0\nT = jnp.arange(100)\n\n# Need the `seed` effect handler in a context manager because of\n# the need for a PRNG key within `numpyro.sample`\nwith numpyro.handlers.seed(rng_seed=42):\n    final_location, locations = scan(random_walk, init=init_0, xs=T)\n\nplt.plot(T, locations)\nplt.title('Simulated Gaussian Random Walk');\n```\n\n![img](/static/images/scan_jax/scan_fig2.png)\n\n### Aside: What if I didn't use `numpyro.handlers.seed` there?\n\nNote the addition of `numpyro.handlers.seed`. This is required due to how `numpyro` requires an explicit PRNG key when you `sample` from a distribution, so this `seed` effect handler will automatically do the `split`s on the key within each loop of the `scan` function.\n\nOtherwise, if you set up an explicit key with `scan` this is what you'd get:\n\n```python\n# What happens if you don't use `numpyro.handlers.seed`?\nprng_key = random.PRNGKey(42)\n\ndef random_walk_nokey(value, x):\n    # Being really explicit here\n    value = value + numpyro.sample('x', dist.Normal(0, 1.), rng_key=prng_key)\n    return value, value\n\ninit_0 = 0\nn_steps = 100\n\nstate, final_result = scan(random_walk_nokey, init=init_0, xs=jnp.arange(n_steps))\n\nplt.plot(jnp.arange(n_steps), final_result);\n```\n\n![img](/static/images/scan_jax/scan_fig3.png)\n\nSo that's why you need to use the handler!\n","srcMarkdownNoYaml":"\n\n# Learning `scan` with `jax` and `numpyro`\n\nLearning `scan` - it's all over the `numpyro` [time series examples](https://num.pyro.ai/en/stable/examples/holt_winters.html) so if I want to implement time series in `numpyro` from scratch, I'll need to better understand it.\n\nIn the context of time series models, `scan` is helpful because it allows us to iterate over sequences (without a cumbersome `for` loop) while maintaining state across each iteration.\n\n## Elements of a `scan`\n\nFirst, let's break down an example `scan` function into its' components:\n\n![img](/static/images/scan_jax/scan_components.png)\n\n# Trivial Example - Cumulative Sum\n\n- [From The Differential Programming Tutorial - Loopy Carry, by Eric Ma](https://ericmjl.github.io/dl-workshop/02-jax-idioms/02-loopy-carry.html)\n\nWe'll start with the cumsum example from [From The Differential Programming Tutorial - Loopy Carry, by Eric Ma](https://ericmjl.github.io/dl-workshop/02-jax-idioms/02-loopy-carry.html). We can implement a cumsum with a `for` loop like:\n\n```python\nfrom jax import random\nimport jax.numpy as jnp\n\n# xs\nxs = jnp.array([1, 2, 3, 5, 7, 11, 13, 17])\n\nresult = []\ncumsum = 0\nfor el in xs:\n    cumsum += el\n    result.append(cumsum)\njnp.array(result)\n```\n\n```\nArray([ 1,  3,  6, 11, 18, 29, 42, 59], dtype=int32)\n```\n\nNow, instead of a loop, we rewrite it with `jax.lax.scan`:\n\n```python\nfrom jax import lax\n\ndef cumsum(cumsum, el):\n    \"\"\"\n    Parameters\n    ----------\n    cumsum\n        The result from the previous loop, aka the 'carried over' result\n    el\n        The current element in the sequence in `xs`\n    \"\"\"\n    cumsum += el\n    return cumsum, cumsum # ('carryover', 'accumulated')\n\ninit_sum = 0\nfinal, result = lax.scan(cumsum, init_sum, xs)\nprint(final)\nprint(result)\n```\n\n```\n59\n[ 1  3  6 11 18 29 42 59]\n```\n\nWe see that `lax.scan` returned two things:\n\n- The first item is the latest value of the carried value `cumsum`\n- The second item being returned is an array where each iteration appended the latest value of `cumsum` to the end.\n\nTo make it a little more concrete, here's a GIF that steps through each iteration:\n\n![img](/static/images/scan_jax/scan.gif)\n\nSee that the scanned function returns two items: the first goes back into the loop while the second is appended to an array that acts as a 'running tally' of values from each iteration. You can also pass `None` here if you don't need it.\n\n## Trivial Example 2: A little more of the `scan` function with compounding interest\n\nThe first two parameters in the input function can have arbitrary names but **their order matters**. The first item is the 'carried over value', aka the `carry`. The second item is the current element in the `xs` input array.\n\nSimilarly the input function must have two outputs. The first output becomes the new 'carried over value' that will feed back into the input function, while the second output gets appended to an output `jax` array.\n\nLet's have a concrete example in which we calculate compounded interest for a $100 investment with a 4% interest rate:\n\n```python\n# Define the input function to apply at each time step\ndef interest_growth(value, x):\n    value = value * 1.04\n    return value, value # ('carried over value', 'accumulated array')\n\n# Define the initial state and input sequence\ninit_state = 100.0\nT = jnp.array([1, 2, 3, 4, 5])\nT = jnp.arange(1, 30)\n\n# Apply the scan function\nfinal_state, results = lax.scan(f=interest_growth, init=init_state, xs=T)\n\nprint(final_state)\nprint(results)\n```\n\n```\n311.8648\n[104.       108.159996 112.48639  116.98584  121.66527  126.531876\n 131.59314  136.85686  142.33113  148.02437  153.94534  160.10315\n 166.50726  173.16754  180.09424  187.298    194.78992  202.58151\n 210.68477  219.11215  227.87663  236.99168  246.47134  256.3302\n 266.5834   277.24673  288.33658  299.87003  311.8648  ]\n```\n\n![img](/static/images/scan_jax/scan_fig1.png)\n\nAnd we see the effect of the interest compounding over time.\n\n## Trivial Example 3: `scan` in `numpyro` to sample from a distribution\n\nAnd what I'm really interested in is learning `scan` in the context of doing time series in `numpyro`.\n\n`numpyro` has it's own (experimental) implementation of `scan` which allows us to iteratively sample from `numpyro` primitives like `numpyro.distributions`.\n\nHere's a simple example of a random walk:\n\n$$\ny_{t+1} = y_t + \\epsilon, \\quad \\epsilon \\sim \\mathcal{N}(0,1)\n$$\n\nOr, equivalently:\n\n$$\n\\begin{aligned}\ny_t &= \\mu_t\\\\\n\\mu_{t+1} &= \\mu_t + \\epsilon_\\mu, \\quad \\epsilon_\\mu \\sim \\mathcal{N}(0, 1)\\\\\n\\end{aligned}\n$$\n\nWe need to use `scan` because each subsequent value of $\\mu_{t+1}$ depends on its previous value $\\mu_{t}$.\n\nTo do this within a `scan` we'll also need to introduce an [effect handler](https://num.pyro.ai/en/stable/handlers.html#seed): `numpyro.handlers.seed` and run the `scan` function within that context.\n\n```python\n# Import libraries\nimport numpyro\nfrom numpyro.contrib.control_flow import scan\nimport numpyro.distributions as dist\nimport matplotlib.pyplot as plt\n\n# Define our random walk function as an input into `scan`\ndef random_walk(value, x):\n    value = numpyro.sample('x', dist.Normal(value, 1.))\n    # Which is the same as if we were very explicit:\n    # value = value + numpyro.sample('x', dist.Normal(0, 1.))\n    return value, value\n\ninit_0 = 0\nT = jnp.arange(100)\n\n# Need the `seed` effect handler in a context manager because of\n# the need for a PRNG key within `numpyro.sample`\nwith numpyro.handlers.seed(rng_seed=42):\n    final_location, locations = scan(random_walk, init=init_0, xs=T)\n\nplt.plot(T, locations)\nplt.title('Simulated Gaussian Random Walk');\n```\n\n![img](/static/images/scan_jax/scan_fig2.png)\n\n### Aside: What if I didn't use `numpyro.handlers.seed` there?\n\nNote the addition of `numpyro.handlers.seed`. This is required due to how `numpyro` requires an explicit PRNG key when you `sample` from a distribution, so this `seed` effect handler will automatically do the `split`s on the key within each loop of the `scan` function.\n\nOtherwise, if you set up an explicit key with `scan` this is what you'd get:\n\n```python\n# What happens if you don't use `numpyro.handlers.seed`?\nprng_key = random.PRNGKey(42)\n\ndef random_walk_nokey(value, x):\n    # Being really explicit here\n    value = value + numpyro.sample('x', dist.Normal(0, 1.), rng_key=prng_key)\n    return value, value\n\ninit_0 = 0\nn_steps = 100\n\nstate, final_result = scan(random_walk_nokey, init=init_0, xs=jnp.arange(n_steps))\n\nplt.plot(jnp.arange(n_steps), final_result);\n```\n\n![img](/static/images/scan_jax/scan_fig3.png)\n\nSo that's why you need to use the handler!\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"a-friendly-introduction-to-scan-with-jax.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.52","theme":{"light":"cosmo"},"title-block-banner":true,"title":"A friendly introduction to scan with JAX","date":"2023-12-29","categories":["python"],"draft":false,"summary":"A friendly introduction to `scan` with JAX and numpyro","images":["/static/images/scan_jax/scan_components.png","/static/images/scan_jax/scan.gif","/static/images/scan_jax/scan_fig1.png","/static/images/scan_jax/scan_fig2.png","/static/images/scan_jax/scan_fig3.png"],"layout":"PostLayout"},"extensions":{"book":{"multiFile":true}}}},"draft":false,"projectFormats":["html"]}