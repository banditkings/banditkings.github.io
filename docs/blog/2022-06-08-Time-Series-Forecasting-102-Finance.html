<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.52">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2022-06-08">

<title>Time Series Forecasting 102 for Finance Analysts – banditkings</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="..//static/logo/logo.svg" rel="icon" type="image/svg+xml">
<script src="../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-R6SHJFF7F7"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-R6SHJFF7F7', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"implied",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary","functionality","tracking","targeting"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  ,
"language":"en"
  });
});
</script> 
  

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../static/logo/logo.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">banditkings</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../notes.html"> 
<span class="menu-text">Notebooks</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/banditkings"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Time Series Forecasting 102 for Finance Analysts</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">python</div>
                <div class="quarto-category">forecasting</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 8, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="how-can-i-tell-if-my-forecast-is-any-good" class="level2">
<h2 class="anchored" data-anchor-id="how-can-i-tell-if-my-forecast-is-any-good">How can I tell if my forecast is any good?</h2>
<p>In our <a href="../blog/2022-06-03-Time-Series-Forecasting-101-Finance.html">last conversation</a>, we shared some examples of time series forecasting models ranging from classical time series methods, judgment-based forecasts and rules of thumb, regression-based models, and more. How do you know which one to use, and which one is the best?</p>
<p>To start, the definition of ‘best’ depends on the problem you’re trying to solve. Imagine yourself as a revenue analyst, here are the kinds of forecasting questions you’d ask and answer:</p>
<ol type="1">
<li>What’s the expected revenue for product X this quarter?</li>
<li>What would the revenue for product X be if we increased our direct marketing by $Y?</li>
</ol>
<p>For the first question, the ‘best’ model is the model that is the most ‘accurate’. For the second question, you’re more interested building the best possible estimate of how those relationships affect the outcome.</p>
<p>For this article, I’ll focus on answering the first question, and will answer the second question in a follow-up article.</p>
</section>
<section id="accuracy---the-basics" class="level2">
<h2 class="anchored" data-anchor-id="accuracy---the-basics">Accuracy - The Basics</h2>
<section id="error" class="level3">
<h3 class="anchored" data-anchor-id="error">Error</h3>
<p>To help us answer the first question “What’s the expected revenue for product X this quarter?”, you might come up with a number and then measure how your forecast differed from what actually happened <em>after the fact</em>. Here’s an example:</p>
<p><span class="math display">\[
\text{Error} = \text{forecast} - \text{actuals}
\]</span></p>
<p>So let’s say that you predicted that revenue will be $26M, but the actuals came in at $25M. So the error is $26M-$25M = $1M.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>product</th>
<th>forecast</th>
<th>actuals</th>
<th>error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Product 1</td>
<td>26</td>
<td>25</td>
<td>1</td>
</tr>
</tbody>
</table>
</section>
<section id="how-to-lie-with-accuracy" class="level3">
<h3 class="anchored" data-anchor-id="how-to-lie-with-accuracy">How to Lie with Accuracy</h3>
<p>While this is a very simple and straightforward example, <strong>you’d be surprised how this can get you into trouble</strong>.</p>
<p>Here’s an example that I’ve seen here at work. Let’s say that you are forecasting for not just one product, but <em>two</em> products. Then naively, how would you calculate the total error across <em>all</em> of your products? Let’s say that <span class="math inline">\(\text{Error}_1\)</span> is the error for product 1 and <span class="math inline">\(\text{Error}_2\)</span> is the error for product 2, then the Total Error would be the total of these two error numbers:</p>
<p><span class="math display">\[
\begin{aligned}
\text{Total Error} &amp;= \text{Error}_1 + \text{Error}_2 \\
&amp;=(\text{forecast}_1 - \text{actuals}_1) + (\text{forecast}_2 - \text{actuals}_2)
\end{aligned}
\]</span></p>
<p>Can you spot the problem? Imagine that <span class="math inline">\(\text{Error}_2\)</span> is negative. To make it concrete, imagine that <span class="math inline">\(\text{Error}_1\)</span> is still $1M and <span class="math inline">\(\text{Error}_2\)</span> is $22M - $23M = $1M, then the Total Error is $1M - $1M = $0M.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>product</th>
<th>forecast</th>
<th>actuals</th>
<th>error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Product 1</td>
<td>26</td>
<td>25</td>
<td>1</td>
</tr>
<tr class="even">
<td>Product 2</td>
<td>22</td>
<td>23</td>
<td>-1</td>
</tr>
<tr class="odd">
<td>Total</td>
<td>48</td>
<td>48</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Great, we have a perfect model! Then, if we want to find out how well this model performed <em>on average</em> you can take the mean:</p>
<p><span class="math display">\[
\begin{aligned}
\text{Mean Error} &amp;= \frac{1}{n}\text{Total Error} \\
&amp;= \frac{1}{2} * 0 \\
&amp;= 0
\end{aligned}
\]</span></p>
<blockquote class="blockquote">
<p>Did we just create the perfect model?</p>
</blockquote>
<p>No! The errors just offset. While you can happily report that your model reported <em>perfect</em> accuracy at the aggregated level, this might make you overconfident in how well your model is <em>truly</em> performing. And as analysts, our north star should be <em>truth</em>.</p>
</section>
<section id="mean-absolute-error" class="level3">
<h3 class="anchored" data-anchor-id="mean-absolute-error">Mean Absolute Error</h3>
<p>So how do we be more honest? First off, you can solve this issue by taking the <em>absolute value</em> of the errors. Then in the previous example, the Total Error becomes $2M instead of $0, and you have a much better measure of the true accuracy of your model.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>product</th>
<th>forecast</th>
<th>actuals</th>
<th>absolute error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Product 1</td>
<td>26</td>
<td>25</td>
<td>1</td>
</tr>
<tr class="even">
<td>Product 2</td>
<td>22</td>
<td>23</td>
<td>1</td>
</tr>
<tr class="odd">
<td>Mean</td>
<td></td>
<td></td>
<td>MAE: <strong>2/2 = 1</strong></td>
</tr>
</tbody>
</table>
<p>So in this example, this better reflects the reality that the average forecast was off by $1M. And this error metric is still fantastic for explainability because it’s easy to understand.</p>
<p>But what if the scales of the two products were drastically different? Let’s say, sales in product 1 were in $M (millions) and sales in product 2 were in $K (thousands). Then you would be potentially overestimating or underestimating the average performance of your model!</p>
<p>We can solve this by <em>scaling</em> our performance metrics.</p>
</section>
</section>
<section id="scaled-errors" class="level2">
<h2 class="anchored" data-anchor-id="scaled-errors">Scaled Errors</h2>
<p>In order to compare forecasts in which the underlying data has widely different scales, you should use a scaled error metric.</p>
<section id="mean-absolute-percent-error" class="level3">
<h3 class="anchored" data-anchor-id="mean-absolute-percent-error">Mean Absolute Percent Error</h3>
<p>How many of us have been asked to provide a forecast or a prediction that should be within +/- 2% of the final number? This is a great example of an accuracy measure, and is known as “Mean Absolute Percent Error” or MAPE. Like Mean Absolute Error (MAE), MAPE is very easy to understand, calculate, and explain. It can also be used when you have forecasts at different scales.</p>
<p><span class="math display">\[
\begin{aligned}
\text{MAPE} &amp;= \frac{100\%}{n} \times \left(\frac{|\text{Error}_1|}{\text{Actuals}_1} + \frac{|\text{Error}_2|}{\text{Actuals}_2} \right) \\
&amp;= \frac{100\%}{2} \times \left(\frac{|1|}{25} + \frac{|-1|}{23}\right) \\
&amp;= 4.18\%
\end{aligned}
\]</span></p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 13%">
<col style="width: 11%">
<col style="width: 23%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>product</th>
<th>forecast</th>
<th>actuals</th>
<th>absolute error</th>
<th>absolute percent error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Product 1</td>
<td>26</td>
<td>25</td>
<td>1</td>
<td>1/25 = 4%</td>
</tr>
<tr class="even">
<td>Product 2</td>
<td>22</td>
<td>23</td>
<td>1</td>
<td>1/23 = 4.34%</td>
</tr>
<tr class="odd">
<td>Mean</td>
<td></td>
<td></td>
<td>1</td>
<td>4.18%</td>
</tr>
</tbody>
</table>
</section>
<section id="careful-with-mape" class="level3">
<h3 class="anchored" data-anchor-id="careful-with-mape">Careful with MAPE!</h3>
<p>For many cases, MAPE is an ideal metric to use because of how easy it is for folks to understand and interpret. However, MAPE isn’t perfect - it can be <em>infinitely large</em>. For example, let’s say that you had a revenue forecast at $9M and the actuals came in at $1M. Then, the percent error is 800%. Then, our data becomes:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 13%">
<col style="width: 11%">
<col style="width: 23%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>product</th>
<th>forecast</th>
<th>actuals</th>
<th>absolute error</th>
<th>absolute percent error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Product 1</td>
<td>26</td>
<td>25</td>
<td>1</td>
<td>1/25 = 4%</td>
</tr>
<tr class="even">
<td>Product 2</td>
<td>22</td>
<td>23</td>
<td>1</td>
<td>1/23 = 4.34%</td>
</tr>
<tr class="odd">
<td>Product 3</td>
<td>9</td>
<td>1</td>
<td>8</td>
<td>8/1 = 800%</td>
</tr>
<tr class="even">
<td>Mean</td>
<td></td>
<td></td>
<td></td>
<td><strong>269.5%</strong></td>
</tr>
</tbody>
</table>
<p>Now, instead of making our model look better than it actually is, it’s making it look <em>worse</em> because that one product is skewing the results.</p>
<p>This example is due to the non-symmetric nature of MAPE. If you set your forecast to $0 or very nearly zero, then the percent error will be <strong>at most</strong> 100%. But if you set your forecast infinitely higher than the actuals, then the MAPE would go to infinity too. Here at work I’ve seen scores in the 127,000% MAPE range.</p>
<p>So how do you handle this? You might be tempted to just report the total MAPE score and call it good, right?</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 13%">
<col style="width: 11%">
<col style="width: 23%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>product</th>
<th>forecast</th>
<th>actuals</th>
<th>absolute error</th>
<th>absolute percent error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Product 1</td>
<td>26</td>
<td>25</td>
<td>1</td>
<td>4%</td>
</tr>
<tr class="even">
<td>Product 2</td>
<td>22</td>
<td>23</td>
<td>1</td>
<td>4.34%</td>
</tr>
<tr class="odd">
<td>Product 3</td>
<td>9</td>
<td>1</td>
<td>8</td>
<td>800%</td>
</tr>
<tr class="even">
<td>Total</td>
<td>57</td>
<td>49</td>
<td>10</td>
<td><strong>10/49 = 16.33%</strong></td>
</tr>
</tbody>
</table>
<p>So then you can confidently say that your model is off by +/- 16.33% when you only look at the total aggregated performance. But on average, this doesn’t change the fact that your average model performance accuracy is about 270%. In practice, it’s common to have a single forecast have <em>infinite</em> percent error, which means that the average model performance accuracy goes to infinity too!</p>
<p>How would you compare different models if <em>both models have infinite error</em>?</p>
</section>
</section>
<section id="alternatives-to-mape" class="level2">
<h2 class="anchored" data-anchor-id="alternatives-to-mape">Alternatives to MAPE</h2>
<p>So if you have models that both report <em>infinite</em> errors and want to compare them against each other, then there are two approaches: sMAPE and MASE.</p>
<section id="smape-symmetric-mean-absolute-percent-error" class="level3">
<h3 class="anchored" data-anchor-id="smape-symmetric-mean-absolute-percent-error">sMAPE (Symmetric Mean Absolute Percent Error)</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Symmetric_mean_absolute_percentage_error">‘symmetric’ MAPE score (SMAPE)</a> is a MAPE score that is adjusted for the non-symmetric nature of MAPE and bounds the score between 0% and 200%. However, the interpretation becomes more complicated because they aren’t true percentages in the MAPE sense…rather, you can consider the error to range between 0 and 200, with lower being better.</p>
<p>This is the preferred metric for state of the art forecasting competitions (the M-series) because it lets you get a score across any kinds of time series.</p>
</section>
<section id="mase-mean-absolute-scaled-error" class="level3">
<h3 class="anchored" data-anchor-id="mase-mean-absolute-scaled-error">MASE (Mean Absolute Scaled Error)</h3>
<p>Another common metric is the <a href="https://en.wikipedia.org/wiki/Mean_absolute_scaled_error">Mean Absolute Scaled Error (MASE)</a>, which compares a model’s accuracy against some baseline model. The most common baseline model is a naive model, where the predicted value is simply the most recent historical value. So for instance, in a naive model where you have actual revenue of $0 this month, you would predict that next month’s revenue would also be $0.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>Jan</th>
<th>Feb</th>
<th>Mar</th>
<th>Apr</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Actuals</td>
<td>0</td>
<td>1</td>
<td>4</td>
<td>6</td>
</tr>
<tr class="even">
<td>Naive Prediction</td>
<td></td>
<td>0</td>
<td>1</td>
<td>4</td>
</tr>
<tr class="odd">
<td>Naive Model Error</td>
<td></td>
<td>1</td>
<td>3</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Then, to calculate the scaled error you simply divide your new model’s error by the average Naive error. Here’s an example with a new model that simply predicts 3 for each month after January:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 3%">
<col style="width: 14%">
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Jan</th>
<th>Feb</th>
<th>Mar</th>
<th>Apr</th>
<th>Mean</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Actuals</td>
<td>0</td>
<td>1</td>
<td>4</td>
<td>6</td>
<td></td>
</tr>
<tr class="even">
<td>Naive Prediction</td>
<td></td>
<td>0</td>
<td>1</td>
<td>4</td>
<td></td>
</tr>
<tr class="odd">
<td>Naive Model Error</td>
<td></td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>New Model</td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td></td>
</tr>
<tr class="odd">
<td>Absolute Scaled Error</td>
<td></td>
<td>|3-1|/2 = 1</td>
<td>|3-4|/2 = 1/2</td>
<td>|3-6|/2 = 3/2</td>
<td>(1 + 1/2 + 3/2)/3 = 1</td>
</tr>
</tbody>
</table>
<p>The final MASE Score in the above example is 1, which indicates that this model does not perform any better or worse than the baseline Naive model. If the MASE score was less than 1, that means that the new model’s accuracy is better than the baseline model, while if the MASE score is above 1, that means that the new model’s accuracy is worse.</p>
<p>MASE is useful because it can give you an interpretable forecast, especially when you have an existing baseline that you want to compare against. Often a +/- 2% accuracy metric isn’t possible, but if your model offers a measurable improvement against an existing baseline then it might still be worth using your model despite not getting within 2% MAPE of your target!</p>
</section>
</section>
<section id="summary-of-error-metrics" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-error-metrics">Summary of Error Metrics</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../static/images/timeseries/error_metrics.png" class="img-fluid figure-img"></p>
<figcaption>img</figcaption>
</figure>
</div>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 55%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Metric</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MAE</td>
<td>Most Interpretable</td>
<td>Best if units are the same</td>
</tr>
<tr class="even">
<td>MAPE</td>
<td>Interpretable, works across multiple scales</td>
<td>Can be infinite</td>
</tr>
<tr class="odd">
<td>sMAPE</td>
<td>Scales errors between 0 and 200</td>
<td>Less interpretable than MAPE</td>
</tr>
<tr class="even">
<td>MASE</td>
<td>Easy to interpret, can’t go to infinity</td>
<td>Less interpretable than MAPE</td>
</tr>
</tbody>
</table>
</section>
<section id="validating-the-model-backtesting" class="level2">
<h2 class="anchored" data-anchor-id="validating-the-model-backtesting">Validating the Model (Backtesting)</h2>
<p>The above examples all compared a single point forecast for multiple products, but did you just get lucky that one quarter, or does your method consistently deliver accurate results? How would you know?</p>
<p>The way to answer this question is to use “<a href="https://otexts.com/fpp3/tscv.html">time series cross-validation</a>”, also known as “Backtesting” your forecasting method because you’re testing how your model would have performed back in the day.</p>
<blockquote class="blockquote">
<p>The intuition behind this is that you repeatedly calculate the forecast at different periods in your history, but <em>only using the subset of historical data that would have been available to you at the time</em>.</p>
</blockquote>
<p>This diagram from <a href="https://otexts.com/fpp3/tscv.html">Hyndman’s Forecasting: Principles and Practice</a> explains this concept, where each dot is a point in time. The blue dots represent the historical training data that you use in your algorithm, and the red dot is the point in time in which you forecast:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../static/images/timeseries/cross-validation.png" class="img-fluid figure-img"></p>
<figcaption>img</figcaption>
</figure>
</div>
<p>You then calculate your forecast accuracy using one of the metrics listed above, and calculate the average over all of the historical backtests.</p>
<section id="the-downside-of-judgmental-forecasts" class="level3">
<h3 class="anchored" data-anchor-id="the-downside-of-judgmental-forecasts">The downside of judgmental forecasts</h3>
<p>So this is the downside of using analyst intuition and judgmental forecasts - most of the time you can’t go back in time and recreate your judgmental forecast using the knowledge available to you at that moment in history. So without taking an algorithmic approach, we often find ourselves stuck unable to find ways to measurably improve our forecasts because we fundamentally can’t determine how ‘good’ our forecasts are!</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>In addressing a handful of common error metrics, I’ve left out a lot of details - there are many, many more types of error metrics out there and choosing the right error metric is a challenging task. When evaluating different forecasting models, it’s common to combine and weight the outputs from multiple error metrics and arrive at a weighted ‘score’ in which you base your model selection decision. This is where the art of analysis comes in - not only is it important for you to understand how various models work and how to tweak their performance, you must also impartially create a model selection process that works for you and your business problem.</p>
<p>I also only covered a problem in which ‘best’ means the model with the highest <em>accuracy</em> score (or conversely, the model with the least amount of error). In a future post, I’ll talk about what it means to use a model to find relationships and help you guide decisionmaking, where accuracy takes a backseat to interpretability!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/www\.nelsontang\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">

<div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>